
% Default to the notebook output style

    


% Inherit from the specified cell style.




    
\documentclass[11pt]{article}

    
    
    \usepackage[T1]{fontenc}
    % Nicer default font (+ math font) than Computer Modern for most use cases
    \usepackage{mathpazo}

    % Basic figure setup, for now with no caption control since it's done
    % automatically by Pandoc (which extracts ![](path) syntax from Markdown).
    \usepackage{graphicx}
    % We will generate all images so they have a width \maxwidth. This means
    % that they will get their normal width if they fit onto the page, but
    % are scaled down if they would overflow the margins.
    \makeatletter
    \def\maxwidth{\ifdim\Gin@nat@width>\linewidth\linewidth
    \else\Gin@nat@width\fi}
    \makeatother
    \let\Oldincludegraphics\includegraphics
    % Set max figure width to be 80% of text width, for now hardcoded.
    \renewcommand{\includegraphics}[1]{\Oldincludegraphics[width=.8\maxwidth]{#1}}
    % Ensure that by default, figures have no caption (until we provide a
    % proper Figure object with a Caption API and a way to capture that
    % in the conversion process - todo).
    \usepackage{caption}
    \DeclareCaptionLabelFormat{nolabel}{}
    \captionsetup{labelformat=nolabel}

    \usepackage{adjustbox} % Used to constrain images to a maximum size 
    \usepackage{xcolor} % Allow colors to be defined
    \usepackage{enumerate} % Needed for markdown enumerations to work
    \usepackage{geometry} % Used to adjust the document margins
    \usepackage{amsmath} % Equations
    \usepackage{amssymb} % Equations
    \usepackage{textcomp} % defines textquotesingle
    % Hack from http://tex.stackexchange.com/a/47451/13684:
    \AtBeginDocument{%
        \def\PYZsq{\textquotesingle}% Upright quotes in Pygmentized code
    }
    \usepackage{upquote} % Upright quotes for verbatim code
    \usepackage{eurosym} % defines \euro
    \usepackage[mathletters]{ucs} % Extended unicode (utf-8) support
    \usepackage[utf8x]{inputenc} % Allow utf-8 characters in the tex document
    \usepackage{fancyvrb} % verbatim replacement that allows latex
    \usepackage{grffile} % extends the file name processing of package graphics 
                         % to support a larger range 
    % The hyperref package gives us a pdf with properly built
    % internal navigation ('pdf bookmarks' for the table of contents,
    % internal cross-reference links, web links for URLs, etc.)
    \usepackage{hyperref}
    \usepackage{longtable} % longtable support required by pandoc >1.10
    \usepackage{booktabs}  % table support for pandoc > 1.12.2
    \usepackage[inline]{enumitem} % IRkernel/repr support (it uses the enumerate* environment)
    \usepackage[normalem]{ulem} % ulem is needed to support strikethroughs (\sout)
                                % normalem makes italics be italics, not underlines
    

    
    
    % Colors for the hyperref package
    \definecolor{urlcolor}{rgb}{0,.145,.698}
    \definecolor{linkcolor}{rgb}{.71,0.21,0.01}
    \definecolor{citecolor}{rgb}{.12,.54,.11}

    % ANSI colors
    \definecolor{ansi-black}{HTML}{3E424D}
    \definecolor{ansi-black-intense}{HTML}{282C36}
    \definecolor{ansi-red}{HTML}{E75C58}
    \definecolor{ansi-red-intense}{HTML}{B22B31}
    \definecolor{ansi-green}{HTML}{00A250}
    \definecolor{ansi-green-intense}{HTML}{007427}
    \definecolor{ansi-yellow}{HTML}{DDB62B}
    \definecolor{ansi-yellow-intense}{HTML}{B27D12}
    \definecolor{ansi-blue}{HTML}{208FFB}
    \definecolor{ansi-blue-intense}{HTML}{0065CA}
    \definecolor{ansi-magenta}{HTML}{D160C4}
    \definecolor{ansi-magenta-intense}{HTML}{A03196}
    \definecolor{ansi-cyan}{HTML}{60C6C8}
    \definecolor{ansi-cyan-intense}{HTML}{258F8F}
    \definecolor{ansi-white}{HTML}{C5C1B4}
    \definecolor{ansi-white-intense}{HTML}{A1A6B2}

    % commands and environments needed by pandoc snippets
    % extracted from the output of `pandoc -s`
    \providecommand{\tightlist}{%
      \setlength{\itemsep}{0pt}\setlength{\parskip}{0pt}}
    \DefineVerbatimEnvironment{Highlighting}{Verbatim}{commandchars=\\\{\}}
    % Add ',fontsize=\small' for more characters per line
    \newenvironment{Shaded}{}{}
    \newcommand{\KeywordTok}[1]{\textcolor[rgb]{0.00,0.44,0.13}{\textbf{{#1}}}}
    \newcommand{\DataTypeTok}[1]{\textcolor[rgb]{0.56,0.13,0.00}{{#1}}}
    \newcommand{\DecValTok}[1]{\textcolor[rgb]{0.25,0.63,0.44}{{#1}}}
    \newcommand{\BaseNTok}[1]{\textcolor[rgb]{0.25,0.63,0.44}{{#1}}}
    \newcommand{\FloatTok}[1]{\textcolor[rgb]{0.25,0.63,0.44}{{#1}}}
    \newcommand{\CharTok}[1]{\textcolor[rgb]{0.25,0.44,0.63}{{#1}}}
    \newcommand{\StringTok}[1]{\textcolor[rgb]{0.25,0.44,0.63}{{#1}}}
    \newcommand{\CommentTok}[1]{\textcolor[rgb]{0.38,0.63,0.69}{\textit{{#1}}}}
    \newcommand{\OtherTok}[1]{\textcolor[rgb]{0.00,0.44,0.13}{{#1}}}
    \newcommand{\AlertTok}[1]{\textcolor[rgb]{1.00,0.00,0.00}{\textbf{{#1}}}}
    \newcommand{\FunctionTok}[1]{\textcolor[rgb]{0.02,0.16,0.49}{{#1}}}
    \newcommand{\RegionMarkerTok}[1]{{#1}}
    \newcommand{\ErrorTok}[1]{\textcolor[rgb]{1.00,0.00,0.00}{\textbf{{#1}}}}
    \newcommand{\NormalTok}[1]{{#1}}
    
    % Additional commands for more recent versions of Pandoc
    \newcommand{\ConstantTok}[1]{\textcolor[rgb]{0.53,0.00,0.00}{{#1}}}
    \newcommand{\SpecialCharTok}[1]{\textcolor[rgb]{0.25,0.44,0.63}{{#1}}}
    \newcommand{\VerbatimStringTok}[1]{\textcolor[rgb]{0.25,0.44,0.63}{{#1}}}
    \newcommand{\SpecialStringTok}[1]{\textcolor[rgb]{0.73,0.40,0.53}{{#1}}}
    \newcommand{\ImportTok}[1]{{#1}}
    \newcommand{\DocumentationTok}[1]{\textcolor[rgb]{0.73,0.13,0.13}{\textit{{#1}}}}
    \newcommand{\AnnotationTok}[1]{\textcolor[rgb]{0.38,0.63,0.69}{\textbf{\textit{{#1}}}}}
    \newcommand{\CommentVarTok}[1]{\textcolor[rgb]{0.38,0.63,0.69}{\textbf{\textit{{#1}}}}}
    \newcommand{\VariableTok}[1]{\textcolor[rgb]{0.10,0.09,0.49}{{#1}}}
    \newcommand{\ControlFlowTok}[1]{\textcolor[rgb]{0.00,0.44,0.13}{\textbf{{#1}}}}
    \newcommand{\OperatorTok}[1]{\textcolor[rgb]{0.40,0.40,0.40}{{#1}}}
    \newcommand{\BuiltInTok}[1]{{#1}}
    \newcommand{\ExtensionTok}[1]{{#1}}
    \newcommand{\PreprocessorTok}[1]{\textcolor[rgb]{0.74,0.48,0.00}{{#1}}}
    \newcommand{\AttributeTok}[1]{\textcolor[rgb]{0.49,0.56,0.16}{{#1}}}
    \newcommand{\InformationTok}[1]{\textcolor[rgb]{0.38,0.63,0.69}{\textbf{\textit{{#1}}}}}
    \newcommand{\WarningTok}[1]{\textcolor[rgb]{0.38,0.63,0.69}{\textbf{\textit{{#1}}}}}
    
    
    % Define a nice break command that doesn't care if a line doesn't already
    % exist.
    \def\br{\hspace*{\fill} \\* }
    % Math Jax compatability definitions
    \def\gt{>}
    \def\lt{<}
    % Document parameters
    \title{NumIntegr}
    
    
    

    % Pygments definitions
    
\makeatletter
\def\PY@reset{\let\PY@it=\relax \let\PY@bf=\relax%
    \let\PY@ul=\relax \let\PY@tc=\relax%
    \let\PY@bc=\relax \let\PY@ff=\relax}
\def\PY@tok#1{\csname PY@tok@#1\endcsname}
\def\PY@toks#1+{\ifx\relax#1\empty\else%
    \PY@tok{#1}\expandafter\PY@toks\fi}
\def\PY@do#1{\PY@bc{\PY@tc{\PY@ul{%
    \PY@it{\PY@bf{\PY@ff{#1}}}}}}}
\def\PY#1#2{\PY@reset\PY@toks#1+\relax+\PY@do{#2}}

\expandafter\def\csname PY@tok@w\endcsname{\def\PY@tc##1{\textcolor[rgb]{0.73,0.73,0.73}{##1}}}
\expandafter\def\csname PY@tok@c\endcsname{\let\PY@it=\textit\def\PY@tc##1{\textcolor[rgb]{0.25,0.50,0.50}{##1}}}
\expandafter\def\csname PY@tok@cp\endcsname{\def\PY@tc##1{\textcolor[rgb]{0.74,0.48,0.00}{##1}}}
\expandafter\def\csname PY@tok@k\endcsname{\let\PY@bf=\textbf\def\PY@tc##1{\textcolor[rgb]{0.00,0.50,0.00}{##1}}}
\expandafter\def\csname PY@tok@kp\endcsname{\def\PY@tc##1{\textcolor[rgb]{0.00,0.50,0.00}{##1}}}
\expandafter\def\csname PY@tok@kt\endcsname{\def\PY@tc##1{\textcolor[rgb]{0.69,0.00,0.25}{##1}}}
\expandafter\def\csname PY@tok@o\endcsname{\def\PY@tc##1{\textcolor[rgb]{0.40,0.40,0.40}{##1}}}
\expandafter\def\csname PY@tok@ow\endcsname{\let\PY@bf=\textbf\def\PY@tc##1{\textcolor[rgb]{0.67,0.13,1.00}{##1}}}
\expandafter\def\csname PY@tok@nb\endcsname{\def\PY@tc##1{\textcolor[rgb]{0.00,0.50,0.00}{##1}}}
\expandafter\def\csname PY@tok@nf\endcsname{\def\PY@tc##1{\textcolor[rgb]{0.00,0.00,1.00}{##1}}}
\expandafter\def\csname PY@tok@nc\endcsname{\let\PY@bf=\textbf\def\PY@tc##1{\textcolor[rgb]{0.00,0.00,1.00}{##1}}}
\expandafter\def\csname PY@tok@nn\endcsname{\let\PY@bf=\textbf\def\PY@tc##1{\textcolor[rgb]{0.00,0.00,1.00}{##1}}}
\expandafter\def\csname PY@tok@ne\endcsname{\let\PY@bf=\textbf\def\PY@tc##1{\textcolor[rgb]{0.82,0.25,0.23}{##1}}}
\expandafter\def\csname PY@tok@nv\endcsname{\def\PY@tc##1{\textcolor[rgb]{0.10,0.09,0.49}{##1}}}
\expandafter\def\csname PY@tok@no\endcsname{\def\PY@tc##1{\textcolor[rgb]{0.53,0.00,0.00}{##1}}}
\expandafter\def\csname PY@tok@nl\endcsname{\def\PY@tc##1{\textcolor[rgb]{0.63,0.63,0.00}{##1}}}
\expandafter\def\csname PY@tok@ni\endcsname{\let\PY@bf=\textbf\def\PY@tc##1{\textcolor[rgb]{0.60,0.60,0.60}{##1}}}
\expandafter\def\csname PY@tok@na\endcsname{\def\PY@tc##1{\textcolor[rgb]{0.49,0.56,0.16}{##1}}}
\expandafter\def\csname PY@tok@nt\endcsname{\let\PY@bf=\textbf\def\PY@tc##1{\textcolor[rgb]{0.00,0.50,0.00}{##1}}}
\expandafter\def\csname PY@tok@nd\endcsname{\def\PY@tc##1{\textcolor[rgb]{0.67,0.13,1.00}{##1}}}
\expandafter\def\csname PY@tok@s\endcsname{\def\PY@tc##1{\textcolor[rgb]{0.73,0.13,0.13}{##1}}}
\expandafter\def\csname PY@tok@sd\endcsname{\let\PY@it=\textit\def\PY@tc##1{\textcolor[rgb]{0.73,0.13,0.13}{##1}}}
\expandafter\def\csname PY@tok@si\endcsname{\let\PY@bf=\textbf\def\PY@tc##1{\textcolor[rgb]{0.73,0.40,0.53}{##1}}}
\expandafter\def\csname PY@tok@se\endcsname{\let\PY@bf=\textbf\def\PY@tc##1{\textcolor[rgb]{0.73,0.40,0.13}{##1}}}
\expandafter\def\csname PY@tok@sr\endcsname{\def\PY@tc##1{\textcolor[rgb]{0.73,0.40,0.53}{##1}}}
\expandafter\def\csname PY@tok@ss\endcsname{\def\PY@tc##1{\textcolor[rgb]{0.10,0.09,0.49}{##1}}}
\expandafter\def\csname PY@tok@sx\endcsname{\def\PY@tc##1{\textcolor[rgb]{0.00,0.50,0.00}{##1}}}
\expandafter\def\csname PY@tok@m\endcsname{\def\PY@tc##1{\textcolor[rgb]{0.40,0.40,0.40}{##1}}}
\expandafter\def\csname PY@tok@gh\endcsname{\let\PY@bf=\textbf\def\PY@tc##1{\textcolor[rgb]{0.00,0.00,0.50}{##1}}}
\expandafter\def\csname PY@tok@gu\endcsname{\let\PY@bf=\textbf\def\PY@tc##1{\textcolor[rgb]{0.50,0.00,0.50}{##1}}}
\expandafter\def\csname PY@tok@gd\endcsname{\def\PY@tc##1{\textcolor[rgb]{0.63,0.00,0.00}{##1}}}
\expandafter\def\csname PY@tok@gi\endcsname{\def\PY@tc##1{\textcolor[rgb]{0.00,0.63,0.00}{##1}}}
\expandafter\def\csname PY@tok@gr\endcsname{\def\PY@tc##1{\textcolor[rgb]{1.00,0.00,0.00}{##1}}}
\expandafter\def\csname PY@tok@ge\endcsname{\let\PY@it=\textit}
\expandafter\def\csname PY@tok@gs\endcsname{\let\PY@bf=\textbf}
\expandafter\def\csname PY@tok@gp\endcsname{\let\PY@bf=\textbf\def\PY@tc##1{\textcolor[rgb]{0.00,0.00,0.50}{##1}}}
\expandafter\def\csname PY@tok@go\endcsname{\def\PY@tc##1{\textcolor[rgb]{0.53,0.53,0.53}{##1}}}
\expandafter\def\csname PY@tok@gt\endcsname{\def\PY@tc##1{\textcolor[rgb]{0.00,0.27,0.87}{##1}}}
\expandafter\def\csname PY@tok@err\endcsname{\def\PY@bc##1{\setlength{\fboxsep}{0pt}\fcolorbox[rgb]{1.00,0.00,0.00}{1,1,1}{\strut ##1}}}
\expandafter\def\csname PY@tok@kc\endcsname{\let\PY@bf=\textbf\def\PY@tc##1{\textcolor[rgb]{0.00,0.50,0.00}{##1}}}
\expandafter\def\csname PY@tok@kd\endcsname{\let\PY@bf=\textbf\def\PY@tc##1{\textcolor[rgb]{0.00,0.50,0.00}{##1}}}
\expandafter\def\csname PY@tok@kn\endcsname{\let\PY@bf=\textbf\def\PY@tc##1{\textcolor[rgb]{0.00,0.50,0.00}{##1}}}
\expandafter\def\csname PY@tok@kr\endcsname{\let\PY@bf=\textbf\def\PY@tc##1{\textcolor[rgb]{0.00,0.50,0.00}{##1}}}
\expandafter\def\csname PY@tok@bp\endcsname{\def\PY@tc##1{\textcolor[rgb]{0.00,0.50,0.00}{##1}}}
\expandafter\def\csname PY@tok@fm\endcsname{\def\PY@tc##1{\textcolor[rgb]{0.00,0.00,1.00}{##1}}}
\expandafter\def\csname PY@tok@vc\endcsname{\def\PY@tc##1{\textcolor[rgb]{0.10,0.09,0.49}{##1}}}
\expandafter\def\csname PY@tok@vg\endcsname{\def\PY@tc##1{\textcolor[rgb]{0.10,0.09,0.49}{##1}}}
\expandafter\def\csname PY@tok@vi\endcsname{\def\PY@tc##1{\textcolor[rgb]{0.10,0.09,0.49}{##1}}}
\expandafter\def\csname PY@tok@vm\endcsname{\def\PY@tc##1{\textcolor[rgb]{0.10,0.09,0.49}{##1}}}
\expandafter\def\csname PY@tok@sa\endcsname{\def\PY@tc##1{\textcolor[rgb]{0.73,0.13,0.13}{##1}}}
\expandafter\def\csname PY@tok@sb\endcsname{\def\PY@tc##1{\textcolor[rgb]{0.73,0.13,0.13}{##1}}}
\expandafter\def\csname PY@tok@sc\endcsname{\def\PY@tc##1{\textcolor[rgb]{0.73,0.13,0.13}{##1}}}
\expandafter\def\csname PY@tok@dl\endcsname{\def\PY@tc##1{\textcolor[rgb]{0.73,0.13,0.13}{##1}}}
\expandafter\def\csname PY@tok@s2\endcsname{\def\PY@tc##1{\textcolor[rgb]{0.73,0.13,0.13}{##1}}}
\expandafter\def\csname PY@tok@sh\endcsname{\def\PY@tc##1{\textcolor[rgb]{0.73,0.13,0.13}{##1}}}
\expandafter\def\csname PY@tok@s1\endcsname{\def\PY@tc##1{\textcolor[rgb]{0.73,0.13,0.13}{##1}}}
\expandafter\def\csname PY@tok@mb\endcsname{\def\PY@tc##1{\textcolor[rgb]{0.40,0.40,0.40}{##1}}}
\expandafter\def\csname PY@tok@mf\endcsname{\def\PY@tc##1{\textcolor[rgb]{0.40,0.40,0.40}{##1}}}
\expandafter\def\csname PY@tok@mh\endcsname{\def\PY@tc##1{\textcolor[rgb]{0.40,0.40,0.40}{##1}}}
\expandafter\def\csname PY@tok@mi\endcsname{\def\PY@tc##1{\textcolor[rgb]{0.40,0.40,0.40}{##1}}}
\expandafter\def\csname PY@tok@il\endcsname{\def\PY@tc##1{\textcolor[rgb]{0.40,0.40,0.40}{##1}}}
\expandafter\def\csname PY@tok@mo\endcsname{\def\PY@tc##1{\textcolor[rgb]{0.40,0.40,0.40}{##1}}}
\expandafter\def\csname PY@tok@ch\endcsname{\let\PY@it=\textit\def\PY@tc##1{\textcolor[rgb]{0.25,0.50,0.50}{##1}}}
\expandafter\def\csname PY@tok@cm\endcsname{\let\PY@it=\textit\def\PY@tc##1{\textcolor[rgb]{0.25,0.50,0.50}{##1}}}
\expandafter\def\csname PY@tok@cpf\endcsname{\let\PY@it=\textit\def\PY@tc##1{\textcolor[rgb]{0.25,0.50,0.50}{##1}}}
\expandafter\def\csname PY@tok@c1\endcsname{\let\PY@it=\textit\def\PY@tc##1{\textcolor[rgb]{0.25,0.50,0.50}{##1}}}
\expandafter\def\csname PY@tok@cs\endcsname{\let\PY@it=\textit\def\PY@tc##1{\textcolor[rgb]{0.25,0.50,0.50}{##1}}}

\def\PYZbs{\char`\\}
\def\PYZus{\char`\_}
\def\PYZob{\char`\{}
\def\PYZcb{\char`\}}
\def\PYZca{\char`\^}
\def\PYZam{\char`\&}
\def\PYZlt{\char`\<}
\def\PYZgt{\char`\>}
\def\PYZsh{\char`\#}
\def\PYZpc{\char`\%}
\def\PYZdl{\char`\$}
\def\PYZhy{\char`\-}
\def\PYZsq{\char`\'}
\def\PYZdq{\char`\"}
\def\PYZti{\char`\~}
% for compatibility with earlier versions
\def\PYZat{@}
\def\PYZlb{[}
\def\PYZrb{]}
\makeatother


    % Exact colors from NB
    \definecolor{incolor}{rgb}{0.0, 0.0, 0.5}
    \definecolor{outcolor}{rgb}{0.545, 0.0, 0.0}



    
    % Prevent overflowing lines due to hard-to-break entities
    \sloppy 
    % Setup hyperref package
    \hypersetup{
      breaklinks=true,  % so long urls are correctly broken across lines
      colorlinks=true,
      urlcolor=urlcolor,
      linkcolor=linkcolor,
      citecolor=citecolor,
      }
    % Slightly bigger margins than the latex defaults
    
    \geometry{verbose,tmargin=1in,bmargin=1in,lmargin=1in,rmargin=1in}
    
    

    \begin{document}
    
    
    \maketitle
    
    

    
    \section{Numerical Integration}\label{numerical-integration}

\subsubsection{\texorpdfstring{by
\href{https://sites.google.com/site/rickecon/}{Richard W. Evans},
January
2019}{by Richard W. Evans, January 2019}}\label{by-richard-w.-evans-january-2019}

The code in this Jupyter notebook was written using Python 3.6. All
references cited in this notebook are fully cited in Section 7 at the
end of the notebook.

    \subsection{1. Introduction}\label{introduction}

Integrals of the form \(\int_a^b g(x)dx\) arise often in economic
models. One example is the aggregating of consumption amounts of a
continuum of differentiated goods \(c_t(i)\),

\begin{equation}\label{NumInt_EqArmAggr}
    C_t = \left(\int_0^1 \alpha_i^\frac{1}{\varepsilon}c_t(i)^\frac{\varepsilon-1}{\varepsilon}di\right)^\frac{\varepsilon}{\varepsilon-1}
\end{equation}

where \(C_t\) is aggregate consumption, \(\alpha_i\) is a weight on the
particular amount of consumption of good \(i\), \(\varepsilon\) is the
constant elasticity of substitution between different goods \(i\), and
the measure of goods is normalized to be between 0 and 1, without loss
of generality. This consumption aggregator is often called the Armington
aggregator as it was first proposed in Armington (1969). It is also
known as a Dixit-Stiglitz aggregator after its use in Dixit and Stiglitz
(1977). Another key example of an integral that often occurs in
macroeconomics is the expectations operator on the right-hand-side of
the standard intertermporal Euler equation,

\begin{equation}\label{NumInt_EqEulEx}
  \begin{split}
    u'(c_t) &= \beta E_{z_{t+1}|z_t}\Bigl[(1+r_{t+1}-\delta)u'(c_{t+1})\Bigr] \\
    \Rightarrow\quad u'(c_t) &= \beta\int_a^b \Bigl(1+r_{t+1}(z_{t+1})-\delta\Bigr)u'\Bigl(c_{t+1}(z_{t+1})\Bigr)f(z_{t+1}|z_t)dz_{t+1}
  \end{split}
\end{equation}

where \(a\) and \(b\) are the bounds of the support of \(z_{t+1}\) and
\(f(z_{t+1}|z_t)\) is the pdf of \(z_{t+1}\) that could potentially be
conditional on \(z_t\).

It is a rare convenience when these integrals can be evaluated
analytically. However, it does not take much richness in functional form
to render analytical solutions impossible for many integrals in economic
models. In these cases, the integral must be computed numerically. The
following discussion of numerical integration draws from the great
treatments of the subject in Heer and Maussner (2009, pp. 598-603), Judd
(1998, ch. 7), and Adda and Cooper (2003, pp. 55-60).

    \subsection{2. Newton-Cotes Quadrature}\label{newton-cotes-quadrature}

Newton-Cotes quadrature forumalas approximate the integral of a function
\(\int_a^b g(x)dx\) by evaluating the function at \(N\) equally spaced
nodes \(\{x_1,x_2,...x_N\}\) and weighting those nodes with \(N\)
weights \(\{\omega_1,\omega_2,...\omega_N\}\). The general form of
Newton-Cotes quadrature forumulas is

\begin{equation}\label{NumInt_EqNewtCotesGen}
  \int_a^b g(x)dx \approx \sum_{n=1}^N\omega_n g(x_n)
\end{equation}

    \subsubsection{2.1. Midpoint rule (1 node)}\label{midpoint-rule-1-node}

The midpoint rule is the simplest Newton-Cotes formula and uses only one
node or evaluation of the function. It is simply a Riemann sum
approximation over the domain of the function \(g(x)\). The midpoint
formula simply evaluates the function at the midpoint of the domain of
\(x = \frac{a+b}{2}\) and assumes that the function is a constant at
that level over the entire domain of \(x\in[a,b]\).

\begin{equation}\label{NumInt_EqMidPtRule}
  \int_a^b g(x)dx \approx (b-a)g\left(\frac{a+b}{2}\right)
\end{equation}

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}1}]:} \PY{k+kn}{import} \PY{n+nn}{requests}
        \PY{k+kn}{from} \PY{n+nn}{IPython}\PY{n+nn}{.}\PY{n+nn}{display} \PY{k}{import} \PY{n}{Image}
        
        \PY{c+c1}{\PYZsh{} Download and save the data file Riemann\PYZus{}sum\PYZus{}convergence.png}
        \PY{n}{url} \PY{o}{=} \PY{p}{(}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{https://raw.githubusercontent.com/rickecon/Notebooks/}\PY{l+s+s1}{\PYZsq{}} \PY{o}{+}
               \PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{master/NumIntegr/images/Riemann\PYZus{}sum\PYZus{}convergence.png}\PY{l+s+s1}{\PYZsq{}}\PY{p}{)}
        \PY{n}{image\PYZus{}file} \PY{o}{=} \PY{n}{requests}\PY{o}{.}\PY{n}{get}\PY{p}{(}\PY{n}{url}\PY{p}{,} \PY{n}{allow\PYZus{}redirects}\PY{o}{=}\PY{k+kc}{True}\PY{p}{)}
        \PY{n+nb}{open}\PY{p}{(}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{Riemann\PYZus{}sum\PYZus{}convergence.png}\PY{l+s+s1}{\PYZsq{}}\PY{p}{,} \PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{wb}\PY{l+s+s1}{\PYZsq{}}\PY{p}{)}\PY{o}{.}\PY{n}{write}\PY{p}{(}\PY{n}{image\PYZus{}file}\PY{o}{.}\PY{n}{content}\PY{p}{)}
        \PY{n}{Image}\PY{p}{(}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{Riemann\PYZus{}sum\PYZus{}convergence.png}\PY{l+s+s1}{\PYZsq{}}\PY{p}{)}
\end{Verbatim}

\texttt{\color{outcolor}Out[{\color{outcolor}1}]:}
    
    \begin{center}
    \adjustimage{max size={0.9\linewidth}{0.9\paperheight}}{output_4_0.png}
    \end{center}
    { \hspace*{\fill} \\}
    

    A more sophisticated midpoint rule is the composite midpoint rule, which
breaks up the domain of the function \(g(x)\) into \(N\) intervals and
applies the midpoint rule to each interval. For nodes
\(x_0,x_1,\ldots,x_{N-1}\) with \(x_i=a+\frac{(2i+1)(b-a)}{2N}\), the
composite midpoint rule is given by

\begin{equation}\label{NumInt_EqMidPtRuleComp}
  \int_a^b g(x)dx \approx \frac{b-a}{N}\sum_{i=0}^{N-1}g(x_i)
\end{equation}

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}2}]:} \PY{c+c1}{\PYZsh{} Download and save the data file MidRiemann2.png}
        \PY{n}{url} \PY{o}{=} \PY{p}{(}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{https://raw.githubusercontent.com/rickecon/Notebooks/}\PY{l+s+s1}{\PYZsq{}} \PY{o}{+}
               \PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{master/NumIntegr/images/MidRiemann2.png}\PY{l+s+s1}{\PYZsq{}}\PY{p}{)}
        \PY{n}{image\PYZus{}file} \PY{o}{=} \PY{n}{requests}\PY{o}{.}\PY{n}{get}\PY{p}{(}\PY{n}{url}\PY{p}{,} \PY{n}{allow\PYZus{}redirects}\PY{o}{=}\PY{k+kc}{True}\PY{p}{)}
        \PY{n+nb}{open}\PY{p}{(}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{MidRiemann2.png}\PY{l+s+s1}{\PYZsq{}}\PY{p}{,} \PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{wb}\PY{l+s+s1}{\PYZsq{}}\PY{p}{)}\PY{o}{.}\PY{n}{write}\PY{p}{(}\PY{n}{image\PYZus{}file}\PY{o}{.}\PY{n}{content}\PY{p}{)}
        \PY{n}{Image}\PY{p}{(}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{MidRiemann2.png}\PY{l+s+s1}{\PYZsq{}}\PY{p}{)}
\end{Verbatim}

\texttt{\color{outcolor}Out[{\color{outcolor}2}]:}
    
    \begin{center}
    \adjustimage{max size={0.9\linewidth}{0.9\paperheight}}{output_6_0.png}
    \end{center}
    { \hspace*{\fill} \\}
    

    \subsubsection{2.2. Trapezoid rule (2
nodes)}\label{trapezoid-rule-2-nodes}

The trapezoid rule estimates the integral as the area under a line that
connects the function \(g(x)\) at the two endpoints \(a\) and \(b\).

\begin{equation}\label{NumInt_EqTrapRule}
  \int_a^b g(x)dx \approx \frac{b-a}{2}\bigl[g(a) + g(b)\bigr]
\end{equation}

A more sophisticated trapezoid rule is the composite trapezoid rule,
which breaks up the domain of the function \(g(x)\) into \(N\) intervals
and applies the trapezoid rule to each interval. For nodes
\(x_0,x_1,\ldots,x_N\) with \(x_i=a+i(b-a)/N\), the composite trapezoid
rule is given by

\begin{equation}\label{NumInt_EqTrapRuleComp}
  \int_a^b g(x)dx \approx \frac{b-a}{2N}\left[g(x_0) + 2\sum_{i=1}^{N-1}g(x_i) + g(x_N)\right]
\end{equation}

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}3}]:} \PY{c+c1}{\PYZsh{} Download and save the data file Integration\PYZus{}num\PYZus{}trapezes\PYZus{}notation.png}
        \PY{n}{url} \PY{o}{=} \PY{p}{(}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{https://raw.githubusercontent.com/rickecon/Notebooks/}\PY{l+s+s1}{\PYZsq{}} \PY{o}{+}
               \PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{master/NumIntegr/images/Integration\PYZus{}num\PYZus{}trapezes\PYZus{}notation.png}\PY{l+s+s1}{\PYZsq{}}\PY{p}{)}
        \PY{n}{image\PYZus{}file} \PY{o}{=} \PY{n}{requests}\PY{o}{.}\PY{n}{get}\PY{p}{(}\PY{n}{url}\PY{p}{,} \PY{n}{allow\PYZus{}redirects}\PY{o}{=}\PY{k+kc}{True}\PY{p}{)}
        \PY{n+nb}{open}\PY{p}{(}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{Integration\PYZus{}num\PYZus{}trapezes\PYZus{}notation.png}\PY{l+s+s1}{\PYZsq{}}\PY{p}{,} \PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{wb}\PY{l+s+s1}{\PYZsq{}}\PY{p}{)}\PY{o}{.}\PY{n}{write}\PY{p}{(}\PY{n}{image\PYZus{}file}\PY{o}{.}\PY{n}{content}\PY{p}{)}
        \PY{n}{Image}\PY{p}{(}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{Integration\PYZus{}num\PYZus{}trapezes\PYZus{}notation.png}\PY{l+s+s1}{\PYZsq{}}\PY{p}{)}
\end{Verbatim}

\texttt{\color{outcolor}Out[{\color{outcolor}3}]:}
    
    \begin{center}
    \adjustimage{max size={0.9\linewidth}{0.9\paperheight}}{output_8_0.png}
    \end{center}
    { \hspace*{\fill} \\}
    

    \subsubsection{2.3. Simpson's rule (3
nodes)}\label{simpsons-rule-3-nodes}

Simpson's rule offers a smooth nonlinear (quadratic) alternative the
linear approximations of the midpoint and trapezoid rules. Simpson's
rule finds the unique quadratic function in \(x\) that passes through
the end points and the midpoint of the function \(g(a)\),
\(g\left(\frac{a+b}{2}\right)\), and \(g(b)\), which produces the
following weights and values.

\begin{equation}\label{NumInt_EqSimpsRule}
  \int_a^b g(x)dx \approx \frac{b-a}{6}\left[g(a) + 4g\left(\frac{a+b}{2}\right) + g(b)\right]
\end{equation}

Again, a more sophisticated Simpson's rule is the composite Simpson's
rule, which breaks up the domain of the function \(g(x)\) into \(2N\)
intervals and applies the Simpson's rule to each interval. For nodes
\(x_0,x_1,\ldots,x_{2N}\) with \(x_i=a+i(b-a)/(2N)\), the composite
Simpson's rule is given by

\begin{equation}\label{NumInt_EqTrapRuleComp2}
  \int_a^b g(x)dx \approx \frac{b-a}{6N}\left[g(x_0) + 4\sum_{i=1,3,\ldots}^{2N-1}g(x_i) + 2\sum_{i=2,4,\ldots}^{2N-2}g(x_i) + g(x_{2N})\right]
\end{equation}

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}4}]:} \PY{c+c1}{\PYZsh{} Download and save the data file Simpsons\PYZus{}method\PYZus{}illustration.png}
        \PY{n}{url} \PY{o}{=} \PY{p}{(}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{https://raw.githubusercontent.com/rickecon/Notebooks/}\PY{l+s+s1}{\PYZsq{}} \PY{o}{+}
               \PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{master/NumIntegr/images/Simpsons\PYZus{}method\PYZus{}illustration.png}\PY{l+s+s1}{\PYZsq{}}\PY{p}{)}
        \PY{n}{image\PYZus{}file} \PY{o}{=} \PY{n}{requests}\PY{o}{.}\PY{n}{get}\PY{p}{(}\PY{n}{url}\PY{p}{,} \PY{n}{allow\PYZus{}redirects}\PY{o}{=}\PY{k+kc}{True}\PY{p}{)}
        \PY{n+nb}{open}\PY{p}{(}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{Simpsons\PYZus{}method\PYZus{}illustration.png}\PY{l+s+s1}{\PYZsq{}}\PY{p}{,} \PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{wb}\PY{l+s+s1}{\PYZsq{}}\PY{p}{)}\PY{o}{.}\PY{n}{write}\PY{p}{(}\PY{n}{image\PYZus{}file}\PY{o}{.}\PY{n}{content}\PY{p}{)}
        \PY{n}{Image}\PY{p}{(}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{Simpsons\PYZus{}method\PYZus{}illustration.png}\PY{l+s+s1}{\PYZsq{}}\PY{p}{)}
\end{Verbatim}

\texttt{\color{outcolor}Out[{\color{outcolor}4}]:}
    
    \begin{center}
    \adjustimage{max size={0.9\linewidth}{0.9\paperheight}}{output_10_0.png}
    \end{center}
    { \hspace*{\fill} \\}
    

    \subsubsection{2.4. Exercises}\label{exercises}

    \textbf{Exercise 2.1.} You can verify that the analytical solution to
the integral of the function

\begin{equation*}
  g(x)=0.1x^4 -1.5x^3 + 0.53x^2 + 2x + 1
\end{equation*}

between \(x=-10\) and \(x=10\) is
\(\int_{-10}^{10} g(x)dx = 4,373.3\bar{3}\). Write a Python function
that will take as arguments an anonymous function that the user
specifies representing \(g(x)\), integration bounds \(a\) and \(b\), the
number of intervals \(N\), and

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{method }\OperatorTok{=}\NormalTok{ \{}\StringTok{'midpoint'}\NormalTok{, }\StringTok{'trapezoid'}\NormalTok{, }\StringTok{'Simpsons'}\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

Using the composite methods, evaluate the numerical approximations of
the integral \(\int_a^b g(x)dx\) using all three Newton-Cotes methods in
your function and compare the difference between the values of these
integrals to the true analytical value of the integral.

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}5}]:} \PY{k+kn}{import} \PY{n+nn}{numpy} \PY{k}{as} \PY{n+nn}{np}
        \PY{k}{def} \PY{n+nf}{g}\PY{p}{(}\PY{n}{x}\PY{p}{)}\PY{p}{:}
            \PY{k}{return} \PY{l+m+mf}{0.1}\PY{o}{*}\PY{n}{x}\PY{o}{*}\PY{o}{*}\PY{l+m+mi}{4}\PY{o}{\PYZhy{}}\PY{l+m+mf}{1.5}\PY{o}{*}\PY{n}{x}\PY{o}{*}\PY{o}{*}\PY{l+m+mi}{3}\PY{o}{+}\PY{l+m+mf}{0.53}\PY{o}{*}\PY{n}{x}\PY{o}{*}\PY{o}{*}\PY{l+m+mi}{2}\PY{o}{+}\PY{l+m+mi}{2}\PY{o}{*}\PY{n}{x}\PY{o}{+}\PY{l+m+mi}{1} 
            
        \PY{k}{def} \PY{n+nf}{integral}\PY{p}{(}\PY{n}{g}\PY{p}{,} \PY{n}{a}\PY{p}{,} \PY{n}{b}\PY{p}{,} \PY{n}{N}\PY{p}{,} \PY{n}{method}\PY{p}{)}\PY{p}{:}
            \PY{k}{if} \PY{n}{method} \PY{o}{==} \PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{midpoint}\PY{l+s+s1}{\PYZsq{}}\PY{p}{:}
                \PY{c+c1}{\PYZsh{} calculate vector of N + 1 bar bounds}
                \PY{n}{bit\PYZus{}cuts} \PY{o}{=} \PY{n}{np}\PY{o}{.}\PY{n}{linspace}\PY{p}{(}\PY{n}{a}\PY{p}{,} \PY{n}{b}\PY{p}{,} \PY{n}{N} \PY{o}{+} \PY{l+m+mi}{1}\PY{p}{)}       
                \PY{c+c1}{\PYZsh{}calculate vector of midpoint}
                \PY{n}{mid\PYZus{}vec} \PY{o}{=} \PY{p}{[}\PY{p}{(}\PY{n}{j}\PY{o}{+}\PY{n}{i}\PY{p}{)}\PY{o}{/}\PY{l+m+mi}{2} \PY{k}{for} \PY{n}{i}\PY{p}{,} \PY{n}{j} \PY{o+ow}{in} \PY{n+nb}{zip}\PY{p}{(}\PY{n}{bit\PYZus{}cuts}\PY{p}{[}\PY{p}{:}\PY{o}{\PYZhy{}}\PY{l+m+mi}{1}\PY{p}{]}\PY{p}{,} \PY{n}{bit\PYZus{}cuts}\PY{p}{[}\PY{l+m+mi}{1}\PY{p}{:}\PY{p}{]}\PY{p}{)}\PY{p}{]}
                \PY{c+c1}{\PYZsh{}Evaluate the function at the midpoints and add up the area of all bars}
                \PY{k}{return} \PY{n+nb}{sum}\PY{p}{(}\PY{n}{g}\PY{p}{(}\PY{n}{x}\PY{p}{)} \PY{k}{for} \PY{n}{x} \PY{o+ow}{in} \PY{n}{mid\PYZus{}vec}\PY{p}{)}\PY{o}{*}\PY{p}{(}\PY{n}{b}\PY{o}{\PYZhy{}}\PY{n}{a}\PY{p}{)}\PY{o}{/}\PY{n}{N} 
            \PY{k}{if} \PY{n}{method} \PY{o}{==} \PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{trapezoid}\PY{l+s+s1}{\PYZsq{}}\PY{p}{:}
                \PY{n}{trap\PYZus{}vec} \PY{o}{=} \PY{p}{[}\PY{n}{a}\PY{o}{+}\PY{n}{i}\PY{o}{*}\PY{p}{(}\PY{n}{b}\PY{o}{\PYZhy{}}\PY{n}{a}\PY{p}{)}\PY{o}{/}\PY{n}{N} \PY{k}{for} \PY{n}{i} \PY{o+ow}{in} \PY{n+nb}{range}\PY{p}{(}\PY{n}{N}\PY{o}{+}\PY{l+m+mi}{1}\PY{p}{)}\PY{p}{]}
                \PY{k}{return} \PY{p}{(}\PY{n}{b}\PY{o}{\PYZhy{}}\PY{n}{a}\PY{p}{)}\PY{o}{/}\PY{p}{(}\PY{l+m+mi}{2}\PY{o}{*}\PY{n}{N}\PY{p}{)}\PY{o}{*}\PY{p}{(}\PY{n}{g}\PY{p}{(}\PY{n}{a}\PY{p}{)}\PY{o}{+}\PY{n}{g}\PY{p}{(}\PY{n}{b}\PY{p}{)}\PY{o}{+}\PY{l+m+mi}{2}\PY{o}{*}\PY{n+nb}{sum}\PY{p}{(}\PY{n}{g}\PY{p}{(}\PY{n}{x}\PY{p}{)} \PY{k}{for} \PY{n}{x} \PY{o+ow}{in} \PY{n}{trap\PYZus{}vec}\PY{p}{[}\PY{l+m+mi}{1}\PY{p}{:}\PY{o}{\PYZhy{}}\PY{l+m+mi}{1}\PY{p}{]} \PY{p}{)}\PY{p}{)}
            \PY{k}{if} \PY{n}{method} \PY{o}{==} \PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{simpsons}\PY{l+s+s1}{\PYZsq{}}\PY{p}{:}
                \PY{n}{sim\PYZus{}vec} \PY{o}{=} \PY{p}{[}\PY{n}{a}\PY{o}{+}\PY{n}{i}\PY{o}{*}\PY{p}{(}\PY{n}{b}\PY{o}{\PYZhy{}}\PY{n}{a}\PY{p}{)}\PY{o}{/}\PY{p}{(}\PY{l+m+mi}{2}\PY{o}{*}\PY{n}{N}\PY{p}{)} \PY{k}{for} \PY{n}{i} \PY{o+ow}{in} \PY{n+nb}{range}\PY{p}{(}\PY{l+m+mi}{2}\PY{o}{*}\PY{n}{N}\PY{o}{+}\PY{l+m+mi}{1}\PY{p}{)}\PY{p}{]}
                \PY{k}{return} \PY{p}{(}\PY{n}{g}\PY{p}{(}\PY{n}{a}\PY{p}{)}\PY{o}{+}\PY{l+m+mi}{4}\PY{o}{*}\PY{n+nb}{sum}\PY{p}{(}\PY{n}{g}\PY{p}{(}\PY{n}{x}\PY{p}{)} \PY{k}{for} \PY{n}{x} \PY{o+ow}{in} \PY{n}{sim\PYZus{}vec}\PY{p}{[}\PY{l+m+mi}{1}\PY{p}{:} \PY{o}{\PYZhy{}}\PY{l+m+mi}{1}\PY{p}{:} \PY{l+m+mi}{2}\PY{p}{]}\PY{p}{)}\PYZbs{}
                        \PY{o}{+}\PY{l+m+mi}{2}\PY{o}{*}\PY{n+nb}{sum}\PY{p}{(}\PY{n}{g}\PY{p}{(}\PY{n}{x}\PY{p}{)} \PY{k}{for} \PY{n}{x} \PY{o+ow}{in} \PY{n}{sim\PYZus{}vec}\PY{p}{[}\PY{l+m+mi}{2}\PY{p}{:} \PY{o}{\PYZhy{}}\PY{l+m+mi}{2}\PY{p}{:} \PY{l+m+mi}{2}\PY{p}{]}\PY{p}{)}\PY{o}{+}\PY{n}{g}\PY{p}{(}\PY{n}{b}\PY{p}{)}\PY{p}{)}\PYZbs{}
                        \PY{o}{*}\PY{p}{(}\PY{n}{b}\PY{o}{\PYZhy{}}\PY{n}{a}\PY{p}{)}\PY{o}{/}\PY{p}{(}\PY{l+m+mi}{6}\PY{o}{*}\PY{n}{N}\PY{p}{)}
                
\end{Verbatim}


    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}6}]:} \PY{n}{mid} \PY{o}{=} \PY{n}{integral}\PY{p}{(}\PY{n}{g}\PY{p}{,} \PY{o}{\PYZhy{}}\PY{l+m+mi}{10}\PY{p}{,} \PY{l+m+mi}{10}\PY{p}{,} \PY{l+m+mi}{100000}\PY{p}{,} \PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{midpoint}\PY{l+s+s1}{\PYZsq{}}\PY{p}{)}
        \PY{n}{trap}\PY{o}{=} \PY{n}{integral}\PY{p}{(}\PY{n}{g}\PY{p}{,} \PY{o}{\PYZhy{}}\PY{l+m+mi}{10}\PY{p}{,} \PY{l+m+mi}{10}\PY{p}{,} \PY{l+m+mi}{100000}\PY{p}{,} \PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{trapezoid}\PY{l+s+s1}{\PYZsq{}}\PY{p}{)}
        \PY{n}{sim} \PY{o}{=} \PY{n}{integral}\PY{p}{(}\PY{n}{g}\PY{p}{,} \PY{o}{\PYZhy{}}\PY{l+m+mi}{10}\PY{p}{,} \PY{l+m+mi}{10}\PY{p}{,} \PY{l+m+mi}{100000}\PY{p}{,} \PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{simpsons}\PY{l+s+s1}{\PYZsq{}}\PY{p}{)}
        \PY{n}{true\PYZus{}val} \PY{o}{=} \PY{l+m+mi}{4373}\PY{o}{+}\PY{l+m+mi}{1}\PY{o}{/}\PY{l+m+mi}{3}
        \PY{n+nb}{print}\PY{p}{(}\PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{The intergral using Midpoint method is }\PY{l+s+s2}{\PYZdq{}}\PY{p}{,} \PY{n}{mid}\PY{p}{)}
        \PY{n+nb}{print}\PY{p}{(}\PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{The intergral using Trapezoid method is }\PY{l+s+s2}{\PYZdq{}}\PY{p}{,} \PY{n}{trap}\PY{p}{)}
        \PY{n+nb}{print}\PY{p}{(}\PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{The intergral using Simpsons method is }\PY{l+s+s2}{\PYZdq{}}\PY{p}{,} \PY{n}{sim}\PY{p}{)}
        \PY{n+nb}{print}\PY{p}{(}\PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{Difference between Midpoint method and the true value is }\PY{l+s+s2}{\PYZdq{}}\PY{p}{,} \PY{n}{mid}\PY{o}{\PYZhy{}}\PY{n}{true\PYZus{}val}\PY{p}{)}
        \PY{n+nb}{print}\PY{p}{(}\PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{Difference between Trapezoid method and the true value is }\PY{l+s+s2}{\PYZdq{}}\PY{p}{,} \PY{n}{trap}\PY{o}{\PYZhy{}}\PY{n}{true\PYZus{}val}\PY{p}{)}
        \PY{n+nb}{print}\PY{p}{(}\PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{Difference between Simpsons method and the true value is }\PY{l+s+s2}{\PYZdq{}}\PY{p}{,} \PY{n}{sim}\PY{o}{\PYZhy{}}\PY{n}{true\PYZus{}val}\PY{p}{)}
\end{Verbatim}


    \begin{Verbatim}[commandchars=\\\{\}]
The intergral using Midpoint method is  4373.333331964722
The intergral using Trapezoid method is  4373.333336070682
The intergral using Simpsons method is  4373.333333333377
Difference between Midpoint method and the true value is  -1.3686112652067095e-06
Difference between Trapezoid method and the true value is  2.7373489501769654e-06
Difference between Simpsons method and the true value is  4.3655745685100555e-11

    \end{Verbatim}

    From the comparison, Simpson's method has the smallest difference from
the true integral. Trapezoid method has the largest difference from the
true integral.

    \textbf{Exercise 2.2.} Write a Python function that makes a Newton-Cotes
discrete approximation of the distribution of the normally distributed
variable \(Z \sim N(\mu,\sigma)\). Let this function take as arguments
the mean \(\mu\), the standard deviation \(\sigma\), the number of
equally spaced nodes \(N\) to estimate the distribution, and the number
of standard deviations \(k\) away from \(\mu\) to make the furthest
nodes on either side of \(\mu\). Use the
\href{http://docs.scipy.org/doc/scipy/reference/generated/scipy.stats.norm.html\#scipy.stats.norm}{\texttt{scipy.stats.norm.cdf}}
command for the cdf of the normal distribution to compute the weights
\(\omega_n\) for the nodes \(x_n\). Have this function return a vector
of nodes of \([Z_1,Z_2,...Z_N]\) and a vector of weights
\([\omega_1,\omega_2,...\omega_N]\) such that \(\omega_i\) is given by
the integral under the normal distribution between the midpoints of the
two closest nodes. Define \(f(Z;\mu,\sigma)\) as the pdf of the normal
distribution and \(F(Z;\mu,\sigma)\) as the cdf.

\begin{equation*}
  \begin{split}
    &\omega_i =
      \begin{cases}
        F\left(\frac{Z_1 + Z_2}{2};\mu,\sigma\right) \quad\quad\quad\quad\:\text{if}\quad i = 1 \\
        \int_{Z_{min}}^{Z_{max}}f(Z;\mu,\sigma)dZ \quad\quad\:\:\text{if}\quad 1<i<N \\
        1 - F\left(\frac{Z_{N-1} + Z_{N}}{2};\mu,\sigma\right) \quad\text{if}\quad i = N
      \end{cases} \\
    &\text{where}\quad Z_{min} = \frac{Z_{i-1} + Z_{i}}{2} \quad\text{and}\quad Z_{max} = \frac{Z_{i} + Z_{i+1}}{2}
  \end{split}
\end{equation*}

What are the weights and nodes \(\{\omega_n,Z_n\}_{n=1}^N\) for
\(N=11\)?

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}7}]:} \PY{k+kn}{import} \PY{n+nn}{scipy}\PY{n+nn}{.}\PY{n+nn}{stats} \PY{k}{as} \PY{n+nn}{ss}
        \PY{k+kn}{from} \PY{n+nn}{scipy}\PY{n+nn}{.}\PY{n+nn}{integrate} \PY{k}{import} \PY{n}{quad}
\end{Verbatim}


    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}8}]:} \PY{k}{def} \PY{n+nf}{NewtonCotesNorm}\PY{p}{(}\PY{n}{mu}\PY{p}{,} \PY{n}{sigma}\PY{p}{,} \PY{n}{N}\PY{p}{,} \PY{n}{k}\PY{p}{)}\PY{p}{:}
            \PY{n}{Z} \PY{o}{=} \PY{n}{np}\PY{o}{.}\PY{n}{linspace}\PY{p}{(}\PY{n}{mu}\PY{o}{\PYZhy{}}\PY{n}{k}\PY{o}{*}\PY{n}{sigma}\PY{p}{,} \PY{n}{mu}\PY{o}{+}\PY{n}{k}\PY{o}{*}\PY{n}{sigma}\PY{p}{,} \PY{n}{N}\PY{p}{)}
            \PY{n}{weight} \PY{o}{=} \PY{n}{np}\PY{o}{.}\PY{n}{zeros}\PY{p}{(}\PY{n}{N}\PY{p}{)}
            \PY{n}{weight}\PY{p}{[}\PY{l+m+mi}{0}\PY{p}{]} \PY{o}{=} \PY{n}{ss}\PY{o}{.}\PY{n}{norm}\PY{o}{.}\PY{n}{cdf}\PY{p}{(}\PY{p}{(}\PY{n}{Z}\PY{p}{[}\PY{l+m+mi}{0}\PY{p}{]}\PY{o}{+}\PY{n}{Z}\PY{p}{[}\PY{l+m+mi}{1}\PY{p}{]}\PY{p}{)}\PY{o}{/}\PY{l+m+mi}{2}\PY{p}{,} \PY{n}{mu}\PY{p}{,} \PY{n}{sigma}\PY{p}{)}
            \PY{n}{weight}\PY{p}{[}\PY{n}{N}\PY{o}{\PYZhy{}}\PY{l+m+mi}{1}\PY{p}{]} \PY{o}{=} \PY{l+m+mi}{1}\PY{o}{\PYZhy{}}\PY{n}{ss}\PY{o}{.}\PY{n}{norm}\PY{o}{.}\PY{n}{cdf}\PY{p}{(}\PY{p}{(}\PY{n}{Z}\PY{p}{[}\PY{n}{N}\PY{o}{\PYZhy{}}\PY{l+m+mi}{2}\PY{p}{]}\PY{o}{+}\PY{n}{Z}\PY{p}{[}\PY{n}{N}\PY{o}{\PYZhy{}}\PY{l+m+mi}{1}\PY{p}{]}\PY{p}{)}\PY{o}{/}\PY{l+m+mi}{2}\PY{p}{,} \PY{n}{mu}\PY{p}{,} \PY{n}{sigma}\PY{p}{)}
            \PY{k}{for} \PY{n}{i} \PY{o+ow}{in} \PY{n+nb}{range}\PY{p}{(}\PY{l+m+mi}{1}\PY{p}{,} \PY{n}{N}\PY{o}{\PYZhy{}}\PY{l+m+mi}{1}\PY{p}{)}\PY{p}{:}
                \PY{n+nb}{min}\PY{p}{,} \PY{n+nb}{max} \PY{o}{=} \PY{p}{(}\PY{n}{Z}\PY{p}{[}\PY{n}{i}\PY{o}{\PYZhy{}}\PY{l+m+mi}{1}\PY{p}{]}\PY{o}{+}\PY{n}{Z}\PY{p}{[}\PY{n}{i}\PY{p}{]}\PY{p}{)}\PY{o}{/}\PY{l+m+mi}{2}\PY{p}{,} \PY{p}{(}\PY{n}{Z}\PY{p}{[}\PY{n}{i}\PY{o}{+}\PY{l+m+mi}{1}\PY{p}{]}\PY{o}{+}\PY{n}{Z}\PY{p}{[}\PY{n}{i}\PY{p}{]}\PY{p}{)}\PY{o}{/}\PY{l+m+mi}{2}
                \PY{n}{f} \PY{o}{=} \PY{k}{lambda} \PY{n}{x}\PY{p}{:}\PY{n}{ss}\PY{o}{.}\PY{n}{norm}\PY{o}{.}\PY{n}{pdf}\PY{p}{(}\PY{n}{x}\PY{p}{,} \PY{n}{mu}\PY{p}{,} \PY{n}{sigma}\PY{p}{)}
                \PY{n}{weight}\PY{p}{[}\PY{n}{i}\PY{p}{]} \PY{o}{=} \PY{n}{quad}\PY{p}{(}\PY{n}{f}\PY{p}{,} \PY{n+nb}{min}\PY{p}{,} \PY{n+nb}{max}\PY{p}{)}\PY{p}{[}\PY{l+m+mi}{0}\PY{p}{]}
            \PY{k}{return} \PY{n}{Z}\PY{p}{,} \PY{n}{weight}
        \PY{n}{Z}\PY{p}{,} \PY{n}{weight} \PY{o}{=} \PY{n}{NewtonCotesNorm}\PY{p}{(}\PY{l+m+mi}{0}\PY{p}{,} \PY{l+m+mi}{1}\PY{p}{,} \PY{l+m+mi}{11}\PY{p}{,} \PY{l+m+mi}{3}\PY{p}{)}
        \PY{n+nb}{print}\PY{p}{(}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{Z = }\PY{l+s+s1}{\PYZsq{}}\PY{p}{,} \PY{n}{Z}\PY{p}{)}
        \PY{n+nb}{print}\PY{p}{(}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{weight = }\PY{l+s+s1}{\PYZsq{}}\PY{p}{,} \PY{n}{weight}\PY{p}{)}
        \PY{n+nb}{print}\PY{p}{(}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{The approximation of the normal distribution integral is}\PY{l+s+s1}{\PYZsq{}}\PY{p}{,} \PY{n}{np}\PY{o}{.}\PY{n}{dot}\PY{p}{(}\PY{n+nb}{abs}\PY{p}{(}\PY{n}{Z}\PY{p}{)}\PY{p}{,} \PY{n}{weight}\PY{p}{)}\PY{p}{)}
\end{Verbatim}


    \begin{Verbatim}[commandchars=\\\{\}]
Z =  [-3.  -2.4 -1.8 -1.2 -0.6  0.   0.6  1.2  1.8  2.4  3. ]
weight =  [0.00346697 0.01439745 0.04894278 0.11725292 0.19802845 0.23582284
 0.19802845 0.11725292 0.04894278 0.01439745 0.00346697]
The approximation of the normal distribution integral is 0.7851447585510265

    \end{Verbatim}

    \textbf{Exercise 2.3.} If \(Z\sim N(\mu,\sigma)\), then
\(A\equiv e^Z\sim LN(\mu,\sigma)\) is distributed lognormally and
\(\log(A)\sim N(\mu,\sigma)\). Use your knowledge that \(A\equiv e^Z\),
\(\log(A)\sim N(\mu,\sigma)\), and your function from Exercise 2.2 to
write a function that gives a discrete approximation to the lognormal
distribution. Note: You will not end up with evenly spaced nodes
\([A_1,A_2,...A_N]\), but your weights should be the same as in Exercise
2.2.

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}9}]:} \PY{k}{def} \PY{n+nf}{NewtonCotesLogNorm}\PY{p}{(}\PY{n}{mu}\PY{p}{,} \PY{n}{sigma}\PY{p}{,} \PY{n}{N}\PY{p}{,} \PY{n}{k}\PY{p}{)}\PY{p}{:}
            \PY{n}{Z}\PY{p}{,} \PY{n}{weight} \PY{o}{=} \PY{n}{NewtonCotesNorm}\PY{p}{(}\PY{n}{mu}\PY{p}{,} \PY{n}{sigma}\PY{p}{,} \PY{n}{N}\PY{p}{,} \PY{n}{k}\PY{p}{)}
            \PY{n}{A} \PY{o}{=} \PY{n}{np}\PY{o}{.}\PY{n}{exp}\PY{p}{(}\PY{n}{Z}\PY{p}{)}
            \PY{k}{return} \PY{n}{A}\PY{p}{,} \PY{n}{weight}
\end{Verbatim}


    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}10}]:} \PY{n}{A}\PY{p}{,} \PY{n}{weight} \PY{o}{=} \PY{n}{NewtonCotesLogNorm}\PY{p}{(}\PY{l+m+mi}{0}\PY{p}{,} \PY{l+m+mi}{1}\PY{p}{,} \PY{l+m+mi}{11}\PY{p}{,} \PY{l+m+mi}{3}\PY{p}{)}
         \PY{n+nb}{print}\PY{p}{(}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{A = }\PY{l+s+s1}{\PYZsq{}}\PY{p}{,} \PY{n}{A}\PY{p}{)}
         \PY{n+nb}{print}\PY{p}{(}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{weight = }\PY{l+s+s1}{\PYZsq{}}\PY{p}{,} \PY{n}{weight}\PY{p}{)}
\end{Verbatim}


    \begin{Verbatim}[commandchars=\\\{\}]
A =  [ 0.04978707  0.09071795  0.16529889  0.30119421  0.54881164  1.
  1.8221188   3.32011692  6.04964746 11.02317638 20.08553692]
weight =  [0.00346697 0.01439745 0.04894278 0.11725292 0.19802845 0.23582284
 0.19802845 0.11725292 0.04894278 0.01439745 0.00346697]

    \end{Verbatim}

    \textbf{Exercise 2.4.} Let \(Y_i\) represent the income of individual
\(i\) in the United States for all individuals \(i\). Assume that income
\(Y_i\) is lognormally distributed in the U.S. according to
\(Y_i\sim LN(\mu,\sigma)\), where the mean of log income is
\(\mu = 10.5\) and the standard deviation of log income is
\(\sigma = 0.8\). Use your function from Exercise 2.3 to compute an
approximation of the expected value of income or average income in the
U.S. How does your approximation compare to the exact expected value of
\(E[Y] = e^{\mu + \frac{\sigma^2}{2}}\)?

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}11}]:} \PY{n}{A}\PY{p}{,} \PY{n}{weight} \PY{o}{=} \PY{n}{NewtonCotesLogNorm}\PY{p}{(}\PY{n}{mu}\PY{o}{=}\PY{l+m+mf}{10.5}\PY{p}{,} \PY{n}{sigma}\PY{o}{=}\PY{l+m+mf}{0.8}\PY{p}{,} \PY{n}{N}\PY{o}{=}\PY{l+m+mi}{1000}\PY{p}{,} \PY{n}{k}\PY{o}{=}\PY{l+m+mi}{3}\PY{p}{)}
         \PY{n}{approx} \PY{o}{=} \PY{n+nb}{sum}\PY{p}{(}\PY{n}{A}\PY{o}{*}\PY{n}{weight}\PY{p}{)}
         \PY{n}{exact\PYZus{}val} \PY{o}{=} \PY{n}{np}\PY{o}{.}\PY{n}{exp}\PY{p}{(}\PY{l+m+mf}{10.5}\PY{o}{+}\PY{l+m+mf}{0.8}\PY{o}{*}\PY{o}{*}\PY{l+m+mi}{2}\PY{o}{/}\PY{l+m+mi}{2}\PY{p}{)}
         \PY{n+nb}{print}\PY{p}{(}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{Exact expected value is }\PY{l+s+s1}{\PYZsq{}}\PY{p}{,} \PY{n}{exact\PYZus{}val}\PY{p}{)}
         \PY{n+nb}{print}\PY{p}{(}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{Approximated value is }\PY{l+s+s1}{\PYZsq{}}\PY{p}{,} \PY{n}{approx}\PY{p}{)}
         \PY{n+nb}{print}\PY{p}{(}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{The difference between the two value is }\PY{l+s+s1}{\PYZsq{}}\PY{p}{,} \PY{n+nb}{abs}\PY{p}{(}\PY{n}{exact\PYZus{}val} \PY{o}{\PYZhy{}} \PY{n}{approx}\PY{p}{)}\PY{p}{)}
\end{Verbatim}


    \begin{Verbatim}[commandchars=\\\{\}]
Exact expected value is  50011.087008521754
Approximated value is  49857.019666114036
The difference between the two value is  154.06734240771766

    \end{Verbatim}

    \subsection{3. Gaussian Quadrature}\label{gaussian-quadrature}

    \subsubsection{3.1. Gaussian Quadrature}\label{gaussian-quadrature}

In Newton-Cotes quadrature, the nodes are uniformly spaced. Gaussian
quadrature formulas for approximating an integral take the same
approximation form
\(\int_a^b g(x)dx \approx \sum_{n=1}^N\omega_n g(x_n)\) and optimally
choose the weights \(\omega_n\) and unevenly spaced nodes \(x_n\) given
the total number of nodes \(N\) and some approximating polynomial class
\(h_i(x)\). The \(N\) weights and nodes are chosen to make an
\emph{exact integration} relationship hold. That is, for polynomials of
order \(2N-1\) or less, the \(N\) weights and nodes must exactly satisfy

\begin{equation}\label{NumInt_EqGausQuadGen}
  \int_a^b h_i(x)dx = \sum_{n=1}^N \omega_n h_i(x_n) \quad\text{for}\quad i=0,1,\ldots,2N-1
\end{equation}

where \(h_i(x)\) is an \(i\)-order polynomial in \(x\). If the
\(h_i(x)\) form a basis, this means that every polynomial of degree less
than or equal to \(2N-1\) will be computed exactly using the \(N\)
weights and \(N\) nodes.

As a simple example, suppose we want to approximate an arbitrary
function \(g(x)\) with Gaussian quadrature using a simple class of
polynomials \(h_i(x) = x^{i}\) and only \(N=2\) weights and nodes. The
Gaussian quadrature definition equation above implies a system of four
equations used to determine the four variables
\((\omega_1,\omega_2,x_1,x_2)\) to approximate the integral
\(\int_a^b g(x)dx \approx \sum_{n=1}^N\omega_n g(x_n)\).

\begin{equation}\label{NumInt_EqGausQuadN2}
  \begin{split}
    &\int_a^b dx = \omega_1 + \omega_2 \\
    &\int_a^b x dx = \omega_1 x_1 + \omega_2 x_2 \\
    &\int_a^b x^2 dx = \omega_1 x_1^2 + \omega_2 x_2^2 \\
    &\int_a^b x^3 dx = \omega_1 x_1^3 + \omega_2 x_2^3
  \end{split}
\end{equation}

For \(N=2\), the optimal weights and nodes that solve the system above
are \((\omega_1,\omega_2,x_1,x_2)=(1,1,-0.578,0.578)\). The Python code
to solve this nonlinear system could be a simple root finder such as
\href{http://docs.scipy.org/doc/scipy/reference/generated/scipy.optimize.root.html\#scipy.optimize.root}{\texttt{scipy.optimize.root}}
or one of the constrained minimizers in
\href{http://docs.scipy.org/doc/scipy/reference/generated/scipy.optimize.minimize.html\#scipy.optimize.minimize}{\texttt{scipy.optimize.minimize}}.
In general, the spacing of the nodes will not be uniform.

The accuracy of the Gaussian quadrature approximation of the integral
\(\int_a^b g(x)dx\) increases in the number of nodes \(N\). The accuracy
of the approximation of the integral can also be improved by the choice
of polynomial family \(h_i(x)\). In particular, the families of
orthonormal polynomials have multiple desirable properties. Because of
the orthogonality of their coefficients, the system above is easier to
solve due to the lack of collinearity. Also, the weights \(\omega_n\)
turn out to be the zeros of the orthogonal polynomial family. Lastly,
these orthogonal families of polynomials can give very accurate
solutions to integrals of the form \(\int_a^b w(x)g(x)dx\), where
\(w(x)\) is the weighting function of an orthonormal family of
polynomials.

For finite integration limits,
\href{http://docs.scipy.org/doc/scipy/reference/generated/scipy.integrate.quad.html\#scipy.integrate.quad}{\texttt{scipy.integrate.quad}}
uses a Clenshaw-Curtis method which uses Chebyshev orthogonal
polynomials as basis functions and uses corresponding Chebyshev moments.
If one of the integration limits is infinite,
\href{http://docs.scipy.org/doc/scipy/reference/generated/scipy.integrate.quad.html\#scipy.integrate.quad}{\texttt{scipy.integrate.quad}}
uses Fourier basis functions with the corresponding Fourier moments.

For a more detailed discussion of the theory behind Gaussian quadrature,
see Judd (1998, pp. 257-265) and Heer and Maussner (2009, pp. 599-601).
The general applicability of Gaussian quadrature and its accuracy and
efficiency advantage over Newton-Cotes formulas is summarized by Judd
(1998, p. 265). \textgreater{} "Even when the asymptotic rate of
convergence for Gaussian quadrature is no better than the comparable
Newton-Cotes formula, experience shows that Gaussian formulas often
outperform the alternative Newton-Cotes formula {[}in terms of
accuracy{]}."

    \subsubsection{3.2. Exercises}\label{exercises}

    \textbf{Exercise 3.1.} Approximate the integral of the function in
Exercise 2.1 using Gaussian quadrature with \(N=3\),
\((\omega_1,\omega_2,\omega_3,x_1,x_2,x_3)\). Use the class of
polynomials \(h_i(x)=x^i\). How does the accuracy of your approximated
integral compare to the approximations from Exercise 2.1 and the true
known value of the integral?

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}12}]:} \PY{k+kn}{import} \PY{n+nn}{scipy} \PY{k}{as} \PY{n+nn}{sp}
         \PY{k}{def} \PY{n+nf}{Gaussian}\PY{p}{(}\PY{n}{g}\PY{p}{,} \PY{n}{a}\PY{p}{,} \PY{n}{b}\PY{p}{,} \PY{n}{N}\PY{o}{=}\PY{l+m+mi}{3}\PY{p}{)}\PY{p}{:}
             \PY{n}{init\PYZus{}w} \PY{o}{=} \PY{p}{[}\PY{l+m+mi}{1}\PY{o}{/}\PY{n}{N} \PY{k}{for} \PY{n}{i} \PY{o+ow}{in} \PY{n+nb}{range}\PY{p}{(}\PY{n}{N}\PY{p}{)}\PY{p}{]}
             \PY{n}{init\PYZus{}x} \PY{o}{=} \PY{p}{[}\PY{n}{a}\PY{o}{+}\PY{n}{i}\PY{o}{*}\PY{p}{(}\PY{n}{b}\PY{o}{\PYZhy{}}\PY{n}{a}\PY{p}{)}\PY{o}{/}\PY{p}{(}\PY{n}{N}\PY{o}{\PYZhy{}}\PY{l+m+mi}{1}\PY{p}{)} \PY{k}{for} \PY{n}{i} \PY{o+ow}{in} \PY{n+nb}{range}\PY{p}{(}\PY{n}{N}\PY{p}{)}\PY{p}{]}
             \PY{n}{init\PYZus{}val} \PY{o}{=} \PY{n}{init\PYZus{}w} \PY{o}{+} \PY{n}{init\PYZus{}x}
             \PY{k}{def} \PY{n+nf}{f}\PY{p}{(}\PY{n}{x}\PY{p}{)}\PY{p}{:}
                 \PY{n}{result} \PY{o}{=} \PY{p}{[}\PY{p}{]}
                 \PY{k}{for} \PY{n}{i} \PY{o+ow}{in} \PY{n+nb}{range}\PY{p}{(}\PY{l+m+mi}{2}\PY{o}{*}\PY{n}{N}\PY{p}{)}\PY{p}{:}
                     \PY{n}{weight} \PY{o}{=} \PY{n}{x}\PY{p}{[}\PY{p}{:}\PY{n}{N}\PY{p}{]}
                     \PY{n}{node} \PY{o}{=} \PY{n}{x}\PY{p}{[}\PY{n}{N}\PY{p}{:}\PY{p}{]}
                     \PY{n}{s} \PY{o}{=} \PY{n+nb}{sum}\PY{p}{(}\PY{n}{weight}\PY{p}{[}\PY{n}{k}\PY{p}{]}\PY{o}{*}\PY{p}{(}\PY{n}{node}\PY{p}{[}\PY{n}{k}\PY{p}{]}\PY{o}{*}\PY{o}{*}\PY{n}{i}\PY{p}{)} \PY{k}{for} \PY{n}{k} \PY{o+ow}{in} \PY{n+nb}{range}\PY{p}{(}\PY{n}{N}\PY{p}{)}\PY{p}{)}
                     \PY{n}{result}\PY{o}{.}\PY{n}{append}\PY{p}{(}\PY{p}{(}\PY{n}{b}\PY{o}{*}\PY{o}{*}\PY{p}{(}\PY{n}{i}\PY{o}{+}\PY{l+m+mi}{1}\PY{p}{)}\PY{o}{\PYZhy{}}\PY{n}{a}\PY{o}{*}\PY{o}{*}\PY{p}{(}\PY{n}{i}\PY{o}{+}\PY{l+m+mi}{1}\PY{p}{)}\PY{p}{)}\PY{o}{/}\PY{p}{(}\PY{n}{i}\PY{o}{+}\PY{l+m+mi}{1}\PY{p}{)}\PY{o}{\PYZhy{}}\PY{n}{s}\PY{p}{)}
                 \PY{k}{return} \PY{n+nb}{tuple}\PY{p}{(}\PY{n}{k} \PY{k}{for} \PY{n}{k} \PY{o+ow}{in} \PY{n}{result}\PY{p}{)}
             \PY{n}{vec} \PY{o}{=} \PY{p}{[}\PY{n}{k} \PY{k}{for} \PY{n}{k} \PY{o+ow}{in} \PY{n}{sp}\PY{o}{.}\PY{n}{optimize}\PY{o}{.}\PY{n}{root}\PY{p}{(}\PY{n}{f}\PY{p}{,} \PY{n}{init\PYZus{}val}\PY{p}{)}\PY{p}{[}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{x}\PY{l+s+s1}{\PYZsq{}}\PY{p}{]}\PY{p}{]}
             \PY{n}{weight}\PY{p}{,} \PY{n}{node} \PY{o}{=} \PY{n}{vec}\PY{p}{[}\PY{p}{:}\PY{n}{N}\PY{p}{]}\PY{p}{,} \PY{n}{vec}\PY{p}{[}\PY{n}{N}\PY{p}{:}\PY{p}{]} 
             \PY{n}{count} \PY{o}{=} \PY{l+m+mi}{0}
             \PY{k}{for} \PY{n}{i} \PY{o+ow}{in} \PY{n+nb}{range}\PY{p}{(}\PY{n}{N}\PY{p}{)}\PY{p}{:}
                 \PY{n}{count} \PY{o}{+}\PY{o}{=} \PY{n}{weight}\PY{p}{[}\PY{n}{i}\PY{p}{]}\PY{o}{*}\PY{n}{g}\PY{p}{(}\PY{n}{node}\PY{p}{[}\PY{n}{i}\PY{p}{]}\PY{p}{)}
             \PY{k}{return} \PY{n}{count}
\end{Verbatim}


    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}13}]:} \PY{n}{gau} \PY{o}{=} \PY{n}{Gaussian}\PY{p}{(}\PY{n}{g}\PY{p}{,} \PY{o}{\PYZhy{}}\PY{l+m+mi}{10}\PY{p}{,} \PY{l+m+mi}{10}\PY{p}{)}
         \PY{n}{newton} \PY{o}{=} \PY{n}{integral}\PY{p}{(}\PY{n}{g}\PY{p}{,} \PY{o}{\PYZhy{}}\PY{l+m+mi}{10}\PY{p}{,} \PY{l+m+mi}{10}\PY{p}{,} \PY{l+m+mi}{10000}\PY{p}{,} \PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{midpoint}\PY{l+s+s1}{\PYZsq{}}\PY{p}{)}
         \PY{n}{true\PYZus{}val} \PY{o}{=} \PY{l+m+mi}{4373}\PY{o}{+}\PY{l+m+mi}{1}\PY{o}{/}\PY{l+m+mi}{3}
         \PY{n+nb}{print}\PY{p}{(}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{Approximated integral using Gaussian quadrature is }\PY{l+s+s1}{\PYZsq{}}\PY{p}{,} \PY{n}{gau}\PY{p}{)}
         \PY{n+nb}{print}\PY{p}{(}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{The absolute error using Gaussian quadrature is }\PY{l+s+s1}{\PYZsq{}}\PY{p}{,} \PY{n+nb}{abs}\PY{p}{(}\PY{n}{gau}\PY{o}{\PYZhy{}}\PY{n}{true\PYZus{}val}\PY{p}{)}\PY{p}{)}
         \PY{n+nb}{print}\PY{p}{(}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{Approximated integral using Newton\PYZhy{}Cotes quadrature is }\PY{l+s+s1}{\PYZsq{}}\PY{p}{,} \PY{n}{newton}\PY{p}{)}
         \PY{n+nb}{print}\PY{p}{(}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{The absolute error using Newton\PYZhy{}Cotes quadrature is }\PY{l+s+s1}{\PYZsq{}}\PY{p}{,} \PY{n+nb}{abs}\PY{p}{(}\PY{n}{newton}\PY{o}{\PYZhy{}}\PY{n}{true\PYZus{}val}\PY{p}{)}\PY{p}{)}
\end{Verbatim}


    \begin{Verbatim}[commandchars=\\\{\}]
Approximated integral using Gaussian quadrature is  4373.333333189601
The absolute error using Gaussian quadrature is  1.4373199519468471e-07
Approximated integral using Newton-Cotes quadrature is  4373.33319646663
The absolute error using Newton-Cotes quadrature is  0.00013686670263268752

    \end{Verbatim}

    From the comparison, Gaussian quadrature is more accurate than
Newton-Cotes method.

    \textbf{Exercise 3.2.} Use the Python Gaussian quadrature command
\href{http://docs.scipy.org/doc/scipy/reference/generated/scipy.integrate.quad.html\#scipy.integrate.quad}{\texttt{scipy.integrate.quad}}
to numerically approximate the integral from Exercise 2.1.

\begin{equation*}
  \int_{-10}^{10} g(x)dx \quad\text{where}\quad g(x)=0.1x^4 -1.5x^3 + 0.53x^2 + 2x + 1
\end{equation*}

How does the approximated integral using the
\href{http://docs.scipy.org/doc/scipy/reference/generated/scipy.integrate.quad.html\#scipy.integrate.quad}{\texttt{scipy.integrate.quad}}
command compare to the exact value of the function?

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}14}]:} \PY{n+nb}{print}\PY{p}{(}\PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{Approximated integral using Scipy Gaussian quadrature is }\PY{l+s+s2}{\PYZdq{}}\PY{p}{,} \PY{n}{quad}\PY{p}{(}\PY{n}{g}\PY{p}{,} \PY{o}{\PYZhy{}}\PY{l+m+mi}{10}\PY{p}{,} \PY{l+m+mi}{10}\PY{p}{)}\PY{p}{[}\PY{l+m+mi}{0}\PY{p}{]}\PY{p}{)}
         \PY{n+nb}{print}\PY{p}{(}\PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{The true integral value is }\PY{l+s+s2}{\PYZdq{}}\PY{p}{,} \PY{n}{true\PYZus{}val}\PY{p}{)}
         \PY{n+nb}{print}\PY{p}{(}\PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{Absolute error is }\PY{l+s+s2}{\PYZdq{}}\PY{p}{,} \PY{n+nb}{abs}\PY{p}{(}\PY{n}{true\PYZus{}val} \PY{o}{\PYZhy{}} \PY{n}{quad}\PY{p}{(}\PY{n}{g}\PY{p}{,} \PY{o}{\PYZhy{}}\PY{l+m+mi}{10}\PY{p}{,} \PY{l+m+mi}{10}\PY{p}{)}\PY{p}{[}\PY{l+m+mi}{0}\PY{p}{]}\PY{p}{)}\PY{p}{)}
\end{Verbatim}


    \begin{Verbatim}[commandchars=\\\{\}]
Approximated integral using Scipy Gaussian quadrature is  4373.333333333334
The true integral value is  4373.333333333333
Absolute error is  9.094947017729282e-13

    \end{Verbatim}

    \subsection{4. Monte Carlo Integration}\label{monte-carlo-integration}

High-dimensional integration is highly inefficient using the standard
one-dimensional methods of Newton-Cotes and Gaussian quadrature. The
method of choice in high-dimensional settings is known as Monte Carlo
Integration.

In this section, we detail two types of Monte Carlo integration. The
standard Monte Carlo simulation approach in Section 4.1 uses
pseudo-randomly generated draws from a uniform distribution over the
domain of the function in order to approximate the weights and nodes for
integration. The quasi-Monte Carlo approach in Section 4.2 uses elements
of low-discrepancy sequences over the domain of the function in order to
approximate the integral. Both methods have benefits and drawbacks.

    \subsubsection{4.1. Standard Monte Carlo
integration}\label{standard-monte-carlo-integration}

In the Newton-Cotes quadrature methods of approximating an integral,
nodes and weights for the approximation \(\sum_{n=1}^N\omega_n g(x_n)\)
are chosen without much attention to the effect of the placement of
these nodes or the levels of the weights on the accuracy of the
approximation. Newton-Cotes methods are computationally fast, but lack
in accuracy. Gaussian quadrature methods spend more computational time
choosing "optimal" weights and nodes, but this gives an accuracy payoff
over Newton-Cotes formulas. Monte Carlo integration methods use the
computationally fast method of drawing uniformly from the support of the
variable of integration. These methods depend on a large number of draws
to get high accuracy. Judd (1998, pp. 309-311) spends significant time
explaining that these methods are more correctly called "pseudo-Monte
Carlo methods" because they make use of pseudorandom number generators,
the use of which cannot invoke the law of large numbers or the central
limit theorem. However, the biases introduced by pseudorandom number
generators are rarely significant in practice. Although Monte Carlo
integration methods do not converge as quickly as Gaussian quadrature
methods for functions of one variable, they are especially valuable when
integrating over functions of multiple variables.

Let \(\Omega\subset\mathbb{R}^m\) be the domain of integration. Let
\(\mathbf{x}_1, \mathbf{x}_2, \ldots, \mathbf{x}_N\) be \(N\) uniform
random draws from \(\Omega\). Then we can write the following
approximation of the integral.

\begin{equation}\label{EqMontoCarloIntGen}
  \int_\Omega g(\mathbf{x})d\mathbf{x}\approx V\frac{1}{N}\sum_{n=1}^N g\left(\mathbf{x}_n\right) \quad\text{where}\quad V = \int_\Omega d\mathbf{x}
\end{equation}

The equation above says we can approximate the integral of a function
\(g(\mathbf{x})\) on a domain \(\Omega\) by taking the average of the
evaluations of the function \(g\) at \(N\) random draws of the vector
\(\mathbf{x}_n\) multiplied by the volume of the domain.

An easy example of a univariate integral is \(\int_0^1 x\: dx\) (here
\(g(\mathbf{x}) = x\)). The Monte Carlo approximation formula for this
integral is the following.

\begin{equation}\label{EqMontCarlIntXdX}
  \int_0^1 x\: dx \approx V\frac{1}{N}\sum_{n=1}^N x_n = \frac{1}{N}\sum_{n=1}^N x_n
\end{equation}

It is easy to see that the answer to the exact integral on the
left-hand-side of this integral is 1/2. In the approximation on the
right-hand-side of this equation, \(V\) is the volume of the domain of
\(x\in[0,1]\), which is 1. It is straightforward to see that the average
of \(N\) draws from a uniform distribution between 0 and 1 will converge
quickly to 1/2.

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}15}]:} \PY{k+kn}{import} \PY{n+nn}{numpy} \PY{k}{as} \PY{n+nn}{np}
         \PY{k+kn}{import} \PY{n+nn}{scipy}\PY{n+nn}{.}\PY{n+nn}{stats} \PY{k}{as} \PY{n+nn}{sts}
         
         \PY{c+c1}{\PYZsh{} Approximate integral int\PYZus{}0\PYZca{}1 x dx by Monte Carlo integration}
         \PY{n}{np}\PY{o}{.}\PY{n}{random}\PY{o}{.}\PY{n}{seed}\PY{p}{(}\PY{n}{seed}\PY{o}{=}\PY{l+m+mi}{25}\PY{p}{)}
         
         \PY{c+c1}{\PYZsh{} \PYZsh{} N = 1}
         \PY{c+c1}{\PYZsh{} N\PYZus{}1 = 1}
         \PY{c+c1}{\PYZsh{} mc\PYZus{}draws\PYZus{}1 = sts.uniform.rvs(size=N\PYZus{}1)}
         \PY{c+c1}{\PYZsh{} print(mc\PYZus{}draws\PYZus{}1)}
         \PY{c+c1}{\PYZsh{} approx\PYZus{}int\PYZus{}1 = (1 / N\PYZus{}1) * mc\PYZus{}draws\PYZus{}1}
         \PY{c+c1}{\PYZsh{} print(\PYZsq{}MC approx integral, N=1\PYZsq{}, approx\PYZus{}int\PYZus{}1)}
         
         \PY{c+c1}{\PYZsh{} \PYZsh{} N = 20}
         \PY{c+c1}{\PYZsh{} N\PYZus{}20 = 20}
         \PY{c+c1}{\PYZsh{} mc\PYZus{}draws\PYZus{}20 = sts.uniform.rvs(size=N\PYZus{}20)}
         \PY{c+c1}{\PYZsh{} \PYZsh{} print(mc\PYZus{}draws\PYZus{}20)}
         \PY{c+c1}{\PYZsh{} approx\PYZus{}int\PYZus{}20 = (1 / N\PYZus{}20) * mc\PYZus{}draws\PYZus{}20.sum()}
         \PY{c+c1}{\PYZsh{} print(\PYZsq{}MC approx integral, N=20\PYZsq{}, approx\PYZus{}int\PYZus{}20)}
\end{Verbatim}


    Exercise 4.1 lets you try your hand at coding a classic Monte Carlo
integration approximation of the integral of a function of two variables
to approximate the value of \(\pi\). The area of a circle with radius
\(r=1\) is \(\pi\). A way to visualize the Monte Carlo approximation of
the area of that circle, or \(\pi\), is to enclose the circle in a
square with sides of length 2, in which the \(x\)-axis goes from -1 to 1
and the \(y\)-axis goes from -1 to 1. The points in the Figure are the
uniformly distributed random draws from \((x,y)\in[-1,1]\times[-1,1]\).
Intuitively, the area of the circle is the fraction of the dots (red
dots divided by total dots) that are inside the circle or on the
boundary of the circle, multiplied by the area or volume of the square
in which the circle lies.

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}16}]:} \PY{c+c1}{\PYZsh{} Download and save the data file MonteCarloCircle.png}
         \PY{n}{url} \PY{o}{=} \PY{p}{(}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{https://raw.githubusercontent.com/rickecon/Notebooks/}\PY{l+s+s1}{\PYZsq{}} \PY{o}{+}
                \PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{master/NumIntegr/images/MonteCarloCircle.png}\PY{l+s+s1}{\PYZsq{}}\PY{p}{)}
         \PY{n}{image\PYZus{}file} \PY{o}{=} \PY{n}{requests}\PY{o}{.}\PY{n}{get}\PY{p}{(}\PY{n}{url}\PY{p}{,} \PY{n}{allow\PYZus{}redirects}\PY{o}{=}\PY{k+kc}{True}\PY{p}{)}
         \PY{n+nb}{open}\PY{p}{(}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{MonteCarloCircle.png}\PY{l+s+s1}{\PYZsq{}}\PY{p}{,} \PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{wb}\PY{l+s+s1}{\PYZsq{}}\PY{p}{)}\PY{o}{.}\PY{n}{write}\PY{p}{(}\PY{n}{image\PYZus{}file}\PY{o}{.}\PY{n}{content}\PY{p}{)}
         \PY{n}{Image}\PY{p}{(}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{MonteCarloCircle.png}\PY{l+s+s1}{\PYZsq{}}\PY{p}{)}
\end{Verbatim}

\texttt{\color{outcolor}Out[{\color{outcolor}16}]:}
    
    \begin{center}
    \adjustimage{max size={0.9\linewidth}{0.9\paperheight}}{output_37_0.png}
    \end{center}
    { \hspace*{\fill} \\}
    

    Following the intuition of the previous paragraph and of the figure
above, the exact area of the circle can be written as an integral of the
indicator function of coordinate variables \(x\) and \(y\) in the
following way.

\begin{equation}\label{EqMontCarlIntPiCircInd}
  \begin{split}
    \text{Area} &= \int_\Omega g(x,y)dx\,dy = \pi \\
    &\quad\text{where}\quad g(x,y) =
      \begin{cases}
        1\quad\text{if}\quad x^2 + y^2 \leq 1 \\
        0\quad\text{else}
      \end{cases} \quad\text{and}\quad \Omega = [-1,1]\times[-1,1]
  \end{split}
\end{equation}

The exact integral for the area of a unit radius circle can be Monte
Carlo approximated using the form above resulting in the following
function.

\begin{equation}\label{EqMontCarlIntPiCirc}
  \int_\Omega g(x,y)dx\,dy \approx 4\frac{1}{N}\sum_{n=1}^N g\left(x_n,y_n\right)
\end{equation}

    \subsubsection{4.2. Quasi-Monte Carlo
integration}\label{quasi-monte-carlo-integration}

It is important to realize what Monte Carlo methods really are in
practice. Due to the impracticality of generating truly "random"
sequences, Monte Carlo methods utilize pseudorandom sequences. Any
sequence generated using a pseudorandom number generator will have a
small amount of artificial correlation, and this problem is compounded
in higher dimensions.

Quasi-Monte Carlo methods dispense with the attempt to create
deterministic samples that mimic random samples, and instead embrace
their deterministic character. Judd (1998, ch. 9) defines quasi-Monte
Carlo methods as sampling methods that do not rely on probabilistic
ideas and pseudorandom sequences for constructing the sample and
analyzing the estimate. Quasi-Monte Carlo methods use the same
approximating function \(\sum_{n=1}^N\omega_n g(x_n)\), but draw on
number theory and Fourier analytic methods to create low-discrepancy
sequences that are used as sample points. However, other than the
selcetion of sample points, quasi-Monte Carlo integration proceeds in
exactly the same way as standard Monte Carlo integration as detailed in
the previous section.

Many different deterministic sequences can be used in quasi-Monte Carlo
sampling. All of these "quasirandom" sequences strive for uniformity in
a general sense. Hence it is useful to have a precise way of measuring
the degree to which a point set exhibits uniformity. If we have a
uniformly distributed sequence \(\mathbf{x}_n\) in the \(s\)-dimensional
unit cube \(I^s=[0,1)^s\), we would intuitively expect that every subset
of \(I^s\) with the same volume would contain the same number of points.
This idea is described precisely by the discrepancy of \(\mathbf{x}_n\).
We first define local discrepancy, and then define global discrepancy.

For \(N\) points \(\{\mathbf{x}_n\}_{n=1}^N\) in \(I^s\), \(s\geq0\),
and \(J\subseteq I^s\), the local discrepancy \(D(J;N)\) is defined by

\begin{equation}\label{EqQMCLocalDiscrep}
  D(J;N)=S(J;N)-V(J)N,
\end{equation}

where \(V(J)\) is the volume of the subinterval \(J\) and \(S(J;N)\) is
the number of points from \(\{\mathbf{x}_n\}_{n=1}^N\) that are in
\(J\). If the \(N\) points are uniformly distributed, then the local
discrepancy should be very small for all \(J\)'s.

Figure \ref{FigQMCDiscrepancy} shows a \(2\)-dimensional unit cube
\(I^s=[0,1)^2\) with six points. Three sub-intervals \(A\), \(B\), and
\(C\) are shaded. The local discrepancy of \(A\), which contains \(3\)
points, is calculated from the equation above as
\(D(A;6)=S(A;6)-V(A)6=3-6/2=0\). Similarly, the local discrepancies of
\(B\) and \(C\) are \(0.1267\) and \(0.8\), respectively.

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}17}]:} \PY{c+c1}{\PYZsh{} Download and save the data file NumInt\PYZus{}Discrepancy.png}
         \PY{n}{url} \PY{o}{=} \PY{p}{(}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{https://raw.githubusercontent.com/rickecon/Notebooks/}\PY{l+s+s1}{\PYZsq{}} \PY{o}{+}
                \PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{master/NumIntegr/images/NumInt\PYZus{}Discrepancy.png}\PY{l+s+s1}{\PYZsq{}}\PY{p}{)}
         \PY{n}{image\PYZus{}file} \PY{o}{=} \PY{n}{requests}\PY{o}{.}\PY{n}{get}\PY{p}{(}\PY{n}{url}\PY{p}{,} \PY{n}{allow\PYZus{}redirects}\PY{o}{=}\PY{k+kc}{True}\PY{p}{)}
         \PY{n+nb}{open}\PY{p}{(}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{NumInt\PYZus{}Discrepancy.png}\PY{l+s+s1}{\PYZsq{}}\PY{p}{,} \PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{wb}\PY{l+s+s1}{\PYZsq{}}\PY{p}{)}\PY{o}{.}\PY{n}{write}\PY{p}{(}\PY{n}{image\PYZus{}file}\PY{o}{.}\PY{n}{content}\PY{p}{)}
         \PY{n}{Image}\PY{p}{(}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{NumInt\PYZus{}Discrepancy.png}\PY{l+s+s1}{\PYZsq{}}\PY{p}{)}
\end{Verbatim}

\texttt{\color{outcolor}Out[{\color{outcolor}17}]:}
    
    \begin{center}
    \adjustimage{max size={0.9\linewidth}{0.9\paperheight}}{output_40_0.png}
    \end{center}
    { \hspace*{\fill} \\}
    

    A global concept of discrepancy is given by the star-discrepancy. We
define the star-discrepancy \(\Delta(N)\) of \(N\) points by,

\begin{equation}\label{EqQMCGlobalDiscrep}
  \Delta(N)=\sup_J |D(J;N)|,
\end{equation}

where the supremum is taken over all subsets \(J\) of the form
\(J=\prod_{i=1}^s[0,u_i)\). The star-discrepancy can be thought of as
the worst-case local discrepancy, looking only at subintervals that have
the origin as a corner.

A common class of sequences used in quasi-Monte Carlo sampling is
equidistributed sequences. Equidistributed sequences sequences where the
star-discrepancy \(\Delta(N)\) tends to zero as \(N\) tends to infinity.
In other words, in the limit the proportion of terms falling in any
subinterval is proportional to the length of that interval.

There are a number of equidistributed sequences, and here we will
provide some examples. By way of notation, let \(p_1, p_2, \ldots\)
denote the sequence of prime numbers \(2,3,5,\ldots\), and let
\(\langle x\rangle\) represent the fractional part of \(x\), that is
\(\langle x\rangle = x - \lfloor x\rfloor\). The table below contains
formulas for a number of \(s\)-dimensional equidistributed sequences on
\([0,1)^s\). The figure below shows the first \(1,000\) points for
two-dimensional Weyl, Haber, Niederreiter, and Baker sequences.

\begin{longtable}[]{@{}ll@{}}
\toprule
\begin{minipage}[b]{0.22\columnwidth}\raggedright\strut
Name of Sequence\strut
\end{minipage} & \begin{minipage}[b]{0.52\columnwidth}\raggedright\strut
Formula for \((x_1, x_2, \ldots, x_s)_n\)\strut
\end{minipage}\tabularnewline
\midrule
\endhead
\begin{minipage}[t]{0.22\columnwidth}\raggedright\strut
Weyl\strut
\end{minipage} & \begin{minipage}[t]{0.52\columnwidth}\raggedright\strut
\((\langle np_1^{1/2}\}, \ldots, \langle np_s^{1/2}\})\)\strut
\end{minipage}\tabularnewline
\begin{minipage}[t]{0.22\columnwidth}\raggedright\strut
Haber\strut
\end{minipage} & \begin{minipage}[t]{0.52\columnwidth}\raggedright\strut
\(\left(\left\langle\frac{n(n+1)}{2}p_1^{1/2}\right\rangle,\ldots,\left\langle\frac{n(n+1)}{2}p_s^{1/2}\right\rangle\right)\)\strut
\end{minipage}\tabularnewline
\begin{minipage}[t]{0.22\columnwidth}\raggedright\strut
Niederreiter\strut
\end{minipage} & \begin{minipage}[t]{0.52\columnwidth}\raggedright\strut
\(\left(\left\langle n2^{1/(n+1)}\right\rangle,\ldots,\left\langle n2^{s/(n+1)}\right\rangle\right)\)\strut
\end{minipage}\tabularnewline
\begin{minipage}[t]{0.22\columnwidth}\raggedright\strut
Baker\strut
\end{minipage} & \begin{minipage}[t]{0.52\columnwidth}\raggedright\strut
\((\langle ne^{r_1}\rangle,\ldots,\langle ne^{r_s}\rangle)\), \(r_j\)
rational and distinct\strut
\end{minipage}\tabularnewline
\bottomrule
\end{longtable}

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}18}]:} \PY{c+c1}{\PYZsh{} Download and save the data file NumInt\PYZus{}ComparisonWHNB1000.png}
         \PY{n}{url} \PY{o}{=} \PY{p}{(}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{https://raw.githubusercontent.com/rickecon/Notebooks/}\PY{l+s+s1}{\PYZsq{}} \PY{o}{+}
                \PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{master/NumIntegr/images/NumInt\PYZus{}ComparisonWHNB1000.png}\PY{l+s+s1}{\PYZsq{}}\PY{p}{)}
         \PY{n}{image\PYZus{}file} \PY{o}{=} \PY{n}{requests}\PY{o}{.}\PY{n}{get}\PY{p}{(}\PY{n}{url}\PY{p}{,} \PY{n}{allow\PYZus{}redirects}\PY{o}{=}\PY{k+kc}{True}\PY{p}{)}
         \PY{n+nb}{open}\PY{p}{(}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{NumInt\PYZus{}ComparisonWHNB1000.png}\PY{l+s+s1}{\PYZsq{}}\PY{p}{,} \PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{wb}\PY{l+s+s1}{\PYZsq{}}\PY{p}{)}\PY{o}{.}\PY{n}{write}\PY{p}{(}\PY{n}{image\PYZus{}file}\PY{o}{.}\PY{n}{content}\PY{p}{)}
         \PY{n}{Image}\PY{p}{(}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{NumInt\PYZus{}ComparisonWHNB1000.png}\PY{l+s+s1}{\PYZsq{}}\PY{p}{)}
\end{Verbatim}

\texttt{\color{outcolor}Out[{\color{outcolor}18}]:}
    
    \begin{center}
    \adjustimage{max size={0.9\linewidth}{0.9\paperheight}}{output_42_0.png}
    \end{center}
    { \hspace*{\fill} \\}
    

    Because the equidistributed sequences shown in the table and figure
above rely on ascending sequences of prime numbers, I include some
functions to produce these sequences of primes. The first function
\texttt{isPrime(n)} tells you whether a number \(n\) is a prime or not.
The second function \texttt{primes\_ascend(N)} returns a vector of
length \(N\) of the first \(N\) primes starting from minimum value of 2
(this is the default).

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}19}]:} \PY{k+kn}{import} \PY{n+nn}{numpy} \PY{k}{as} \PY{n+nn}{np}
         
         \PY{k}{def} \PY{n+nf}{isPrime}\PY{p}{(}\PY{n}{n}\PY{p}{)}\PY{p}{:}
             \PY{l+s+sd}{\PYZsq{}\PYZsq{}\PYZsq{}}
         \PY{l+s+sd}{    \PYZhy{}\PYZhy{}\PYZhy{}\PYZhy{}\PYZhy{}\PYZhy{}\PYZhy{}\PYZhy{}\PYZhy{}\PYZhy{}\PYZhy{}\PYZhy{}\PYZhy{}\PYZhy{}\PYZhy{}\PYZhy{}\PYZhy{}\PYZhy{}\PYZhy{}\PYZhy{}\PYZhy{}\PYZhy{}\PYZhy{}\PYZhy{}\PYZhy{}\PYZhy{}\PYZhy{}\PYZhy{}\PYZhy{}\PYZhy{}\PYZhy{}\PYZhy{}\PYZhy{}\PYZhy{}\PYZhy{}\PYZhy{}\PYZhy{}\PYZhy{}\PYZhy{}\PYZhy{}\PYZhy{}\PYZhy{}\PYZhy{}\PYZhy{}\PYZhy{}\PYZhy{}\PYZhy{}\PYZhy{}\PYZhy{}\PYZhy{}\PYZhy{}\PYZhy{}\PYZhy{}\PYZhy{}\PYZhy{}\PYZhy{}\PYZhy{}\PYZhy{}\PYZhy{}\PYZhy{}\PYZhy{}\PYZhy{}\PYZhy{}\PYZhy{}\PYZhy{}\PYZhy{}\PYZhy{}\PYZhy{}}
         \PY{l+s+sd}{    This function returns a boolean indicating whether an integer n is a}
         \PY{l+s+sd}{    prime number}
         \PY{l+s+sd}{    \PYZhy{}\PYZhy{}\PYZhy{}\PYZhy{}\PYZhy{}\PYZhy{}\PYZhy{}\PYZhy{}\PYZhy{}\PYZhy{}\PYZhy{}\PYZhy{}\PYZhy{}\PYZhy{}\PYZhy{}\PYZhy{}\PYZhy{}\PYZhy{}\PYZhy{}\PYZhy{}\PYZhy{}\PYZhy{}\PYZhy{}\PYZhy{}\PYZhy{}\PYZhy{}\PYZhy{}\PYZhy{}\PYZhy{}\PYZhy{}\PYZhy{}\PYZhy{}\PYZhy{}\PYZhy{}\PYZhy{}\PYZhy{}\PYZhy{}\PYZhy{}\PYZhy{}\PYZhy{}\PYZhy{}\PYZhy{}\PYZhy{}\PYZhy{}\PYZhy{}\PYZhy{}\PYZhy{}\PYZhy{}\PYZhy{}\PYZhy{}\PYZhy{}\PYZhy{}\PYZhy{}\PYZhy{}\PYZhy{}\PYZhy{}\PYZhy{}\PYZhy{}\PYZhy{}\PYZhy{}\PYZhy{}\PYZhy{}\PYZhy{}\PYZhy{}\PYZhy{}\PYZhy{}\PYZhy{}\PYZhy{}}
         \PY{l+s+sd}{    INPUTS:}
         \PY{l+s+sd}{    n = scalar, any scalar value}
         
         \PY{l+s+sd}{    OTHER FUNCTIONS AND FILES CALLED BY THIS FUNCTION: None}
         
         \PY{l+s+sd}{    OBJECTS CREATED WITHIN FUNCTION:}
         \PY{l+s+sd}{    i = integer in [2, sqrt(n)]}
         
         \PY{l+s+sd}{    FILES CREATED BY THIS FUNCTION: None}
         
         \PY{l+s+sd}{    RETURN: boolean}
         \PY{l+s+sd}{    \PYZhy{}\PYZhy{}\PYZhy{}\PYZhy{}\PYZhy{}\PYZhy{}\PYZhy{}\PYZhy{}\PYZhy{}\PYZhy{}\PYZhy{}\PYZhy{}\PYZhy{}\PYZhy{}\PYZhy{}\PYZhy{}\PYZhy{}\PYZhy{}\PYZhy{}\PYZhy{}\PYZhy{}\PYZhy{}\PYZhy{}\PYZhy{}\PYZhy{}\PYZhy{}\PYZhy{}\PYZhy{}\PYZhy{}\PYZhy{}\PYZhy{}\PYZhy{}\PYZhy{}\PYZhy{}\PYZhy{}\PYZhy{}\PYZhy{}\PYZhy{}\PYZhy{}\PYZhy{}\PYZhy{}\PYZhy{}\PYZhy{}\PYZhy{}\PYZhy{}\PYZhy{}\PYZhy{}\PYZhy{}\PYZhy{}\PYZhy{}\PYZhy{}\PYZhy{}\PYZhy{}\PYZhy{}\PYZhy{}\PYZhy{}\PYZhy{}\PYZhy{}\PYZhy{}\PYZhy{}\PYZhy{}\PYZhy{}\PYZhy{}\PYZhy{}\PYZhy{}\PYZhy{}\PYZhy{}\PYZhy{}}
         \PY{l+s+sd}{    \PYZsq{}\PYZsq{}\PYZsq{}}
             \PY{k}{for} \PY{n}{i} \PY{o+ow}{in} \PY{n+nb}{range}\PY{p}{(}\PY{l+m+mi}{2}\PY{p}{,} \PY{n+nb}{int}\PY{p}{(}\PY{n}{np}\PY{o}{.}\PY{n}{sqrt}\PY{p}{(}\PY{n}{n}\PY{p}{)} \PY{o}{+} \PY{l+m+mi}{1}\PY{p}{)}\PY{p}{)}\PY{p}{:}
                 \PY{k}{if} \PY{n}{n} \PY{o}{\PYZpc{}} \PY{n}{i} \PY{o}{==} \PY{l+m+mi}{0}\PY{p}{:}
                     \PY{k}{return} \PY{k+kc}{False}
         
             \PY{k}{return} \PY{k+kc}{True}
\end{Verbatim}


    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}20}]:} \PY{k}{def} \PY{n+nf}{primes\PYZus{}ascend}\PY{p}{(}\PY{n}{N}\PY{p}{,} \PY{n}{min\PYZus{}val}\PY{o}{=}\PY{l+m+mi}{2}\PY{p}{)}\PY{p}{:}
             \PY{l+s+sd}{\PYZsq{}\PYZsq{}\PYZsq{}}
         \PY{l+s+sd}{    \PYZhy{}\PYZhy{}\PYZhy{}\PYZhy{}\PYZhy{}\PYZhy{}\PYZhy{}\PYZhy{}\PYZhy{}\PYZhy{}\PYZhy{}\PYZhy{}\PYZhy{}\PYZhy{}\PYZhy{}\PYZhy{}\PYZhy{}\PYZhy{}\PYZhy{}\PYZhy{}\PYZhy{}\PYZhy{}\PYZhy{}\PYZhy{}\PYZhy{}\PYZhy{}\PYZhy{}\PYZhy{}\PYZhy{}\PYZhy{}\PYZhy{}\PYZhy{}\PYZhy{}\PYZhy{}\PYZhy{}\PYZhy{}\PYZhy{}\PYZhy{}\PYZhy{}\PYZhy{}\PYZhy{}\PYZhy{}\PYZhy{}\PYZhy{}\PYZhy{}\PYZhy{}\PYZhy{}\PYZhy{}\PYZhy{}\PYZhy{}\PYZhy{}\PYZhy{}\PYZhy{}\PYZhy{}\PYZhy{}\PYZhy{}\PYZhy{}\PYZhy{}\PYZhy{}\PYZhy{}\PYZhy{}\PYZhy{}\PYZhy{}\PYZhy{}\PYZhy{}\PYZhy{}\PYZhy{}\PYZhy{}}
         \PY{l+s+sd}{    This function generates an ordered sequence of N consecutive prime}
         \PY{l+s+sd}{    numbers, the smallest of which is greater than or equal to 1 using}
         \PY{l+s+sd}{    the Sieve of Eratosthenes algorithm.}
         \PY{l+s+sd}{    (https://en.wikipedia.org/wiki/Sieve\PYZus{}of\PYZus{}Eratosthenes)}
         \PY{l+s+sd}{    \PYZhy{}\PYZhy{}\PYZhy{}\PYZhy{}\PYZhy{}\PYZhy{}\PYZhy{}\PYZhy{}\PYZhy{}\PYZhy{}\PYZhy{}\PYZhy{}\PYZhy{}\PYZhy{}\PYZhy{}\PYZhy{}\PYZhy{}\PYZhy{}\PYZhy{}\PYZhy{}\PYZhy{}\PYZhy{}\PYZhy{}\PYZhy{}\PYZhy{}\PYZhy{}\PYZhy{}\PYZhy{}\PYZhy{}\PYZhy{}\PYZhy{}\PYZhy{}\PYZhy{}\PYZhy{}\PYZhy{}\PYZhy{}\PYZhy{}\PYZhy{}\PYZhy{}\PYZhy{}\PYZhy{}\PYZhy{}\PYZhy{}\PYZhy{}\PYZhy{}\PYZhy{}\PYZhy{}\PYZhy{}\PYZhy{}\PYZhy{}\PYZhy{}\PYZhy{}\PYZhy{}\PYZhy{}\PYZhy{}\PYZhy{}\PYZhy{}\PYZhy{}\PYZhy{}\PYZhy{}\PYZhy{}\PYZhy{}\PYZhy{}\PYZhy{}\PYZhy{}\PYZhy{}\PYZhy{}\PYZhy{}}
         \PY{l+s+sd}{    INPUTS:}
         \PY{l+s+sd}{    N       = integer, number of elements in sequence of consecutive}
         \PY{l+s+sd}{              prime numbers}
         \PY{l+s+sd}{    min\PYZus{}val = scalar \PYZgt{}= 2, the smallest prime number in the consecutive}
         \PY{l+s+sd}{              sequence must be greater\PYZhy{}than\PYZhy{}or\PYZhy{}equal\PYZhy{}to this value}
         
         \PY{l+s+sd}{    OTHER FUNCTIONS AND FILES CALLED BY THIS FUNCTION:}
         \PY{l+s+sd}{        isPrime()}
         
         \PY{l+s+sd}{    OBJECTS CREATED WITHIN FUNCTION:}
         \PY{l+s+sd}{    primes\PYZus{}vec     = (N,) vector, consecutive prime numbers greater than}
         \PY{l+s+sd}{                     min\PYZus{}val}
         \PY{l+s+sd}{    MinIsEven      = boolean, =True if min\PYZus{}val is even, =False otherwise}
         \PY{l+s+sd}{    MinIsGrtrThn2  = boolean, =True if min\PYZus{}val is}
         \PY{l+s+sd}{                     greater\PYZhy{}than\PYZhy{}or\PYZhy{}equal\PYZhy{}to 2, =False otherwise}
         \PY{l+s+sd}{    curr\PYZus{}prime\PYZus{}ind = integer \PYZgt{}= 0, running count of prime numbers found}
         
         \PY{l+s+sd}{    FILES CREATED BY THIS FUNCTION: None}
         
         \PY{l+s+sd}{    RETURN: primes\PYZus{}vec}
         \PY{l+s+sd}{    \PYZhy{}\PYZhy{}\PYZhy{}\PYZhy{}\PYZhy{}\PYZhy{}\PYZhy{}\PYZhy{}\PYZhy{}\PYZhy{}\PYZhy{}\PYZhy{}\PYZhy{}\PYZhy{}\PYZhy{}\PYZhy{}\PYZhy{}\PYZhy{}\PYZhy{}\PYZhy{}\PYZhy{}\PYZhy{}\PYZhy{}\PYZhy{}\PYZhy{}\PYZhy{}\PYZhy{}\PYZhy{}\PYZhy{}\PYZhy{}\PYZhy{}\PYZhy{}\PYZhy{}\PYZhy{}\PYZhy{}\PYZhy{}\PYZhy{}\PYZhy{}\PYZhy{}\PYZhy{}\PYZhy{}\PYZhy{}\PYZhy{}\PYZhy{}\PYZhy{}\PYZhy{}\PYZhy{}\PYZhy{}\PYZhy{}\PYZhy{}\PYZhy{}\PYZhy{}\PYZhy{}\PYZhy{}\PYZhy{}\PYZhy{}\PYZhy{}\PYZhy{}\PYZhy{}\PYZhy{}\PYZhy{}\PYZhy{}\PYZhy{}\PYZhy{}\PYZhy{}\PYZhy{}\PYZhy{}\PYZhy{}}
         \PY{l+s+sd}{    \PYZsq{}\PYZsq{}\PYZsq{}}
             \PY{n}{primes\PYZus{}vec} \PY{o}{=} \PY{n}{np}\PY{o}{.}\PY{n}{zeros}\PY{p}{(}\PY{n}{N}\PY{p}{,} \PY{n}{dtype}\PY{o}{=}\PY{n+nb}{int}\PY{p}{)}
             \PY{n}{MinIsEven} \PY{o}{=} \PY{l+m+mi}{1} \PY{o}{\PYZhy{}} \PY{n}{min\PYZus{}val} \PY{o}{\PYZpc{}} \PY{l+m+mi}{2}
             \PY{n}{MinIsGrtrThn2} \PY{o}{=} \PY{n}{min\PYZus{}val} \PY{o}{\PYZgt{}} \PY{l+m+mi}{2}
             \PY{n}{curr\PYZus{}prime\PYZus{}ind} \PY{o}{=} \PY{l+m+mi}{0}
             \PY{k}{if} \PY{o+ow}{not} \PY{n}{MinIsGrtrThn2}\PY{p}{:}
                 \PY{n}{i} \PY{o}{=} \PY{l+m+mi}{2}
                 \PY{n}{curr\PYZus{}prime\PYZus{}ind} \PY{o}{+}\PY{o}{=} \PY{l+m+mi}{1}
                 \PY{n}{primes\PYZus{}vec}\PY{p}{[}\PY{l+m+mi}{0}\PY{p}{]} \PY{o}{=} \PY{n}{i}
             \PY{n}{i} \PY{o}{=} \PY{n+nb}{min}\PY{p}{(}\PY{l+m+mi}{3}\PY{p}{,} \PY{n}{min\PYZus{}val} \PY{o}{+} \PY{p}{(}\PY{n}{MinIsEven} \PY{o}{*} \PY{l+m+mi}{1}\PY{p}{)}\PY{p}{)}
             \PY{k}{while} \PY{n}{curr\PYZus{}prime\PYZus{}ind} \PY{o}{\PYZlt{}} \PY{n}{N}\PY{p}{:}
                 \PY{k}{if} \PY{n}{isPrime}\PY{p}{(}\PY{n}{i}\PY{p}{)}\PY{p}{:}
                     \PY{n}{curr\PYZus{}prime\PYZus{}ind} \PY{o}{+}\PY{o}{=} \PY{l+m+mi}{1}
                     \PY{n}{primes\PYZus{}vec}\PY{p}{[}\PY{n}{curr\PYZus{}prime\PYZus{}ind} \PY{o}{\PYZhy{}} \PY{l+m+mi}{1}\PY{p}{]} \PY{o}{=} \PY{n}{i}
                 \PY{n}{i} \PY{o}{+}\PY{o}{=} \PY{l+m+mi}{2}
         
             \PY{k}{return} \PY{n}{primes\PYZus{}vec}
\end{Verbatim}


    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}21}]:} \PY{n}{primes\PYZus{}ascend}\PY{p}{(}\PY{l+m+mi}{10}\PY{p}{)}
\end{Verbatim}


\begin{Verbatim}[commandchars=\\\{\}]
{\color{outcolor}Out[{\color{outcolor}21}]:} array([ 2,  3,  5,  7, 11, 13, 17, 19, 23, 29])
\end{Verbatim}
            
    A key distinction between quasirandom sequences and pseudorandom
sequences is that quasirandom sequences do not "look like" random
numbers. As can be seen in the figures above, they generally display
quite obvious patterns. From the outset, quasirandom sequences are
chosen so as to have low discrepancy, and are not encumbered by any
other requirements of random numbers.

However, equidistribution is a rather weak criterion to express the idea
that a sequence is uniform. Even though the discrepancy approaches zero
as \(n\) approaches infinity, the Weyl sequence in the figure above
shows how there will often be large gaps for small \(n\). An alternative
approach is to use low-discrepancy sequences. The goal of a
low-discrepancy sequence is to minimize the star-discrepancy of every
subsequence. In contrast to equidistributed sequences, the algorithms to
generate these sequences take into account the total number of points
desired so that maximum uniformity is achieved for every subsequence,
and not just in the limit.

Halton sequences describe a class of low-discrepancy multidimensional
sequences that fill the interval \([0,1)\). To construct a Halton
sequence, begin with a consecutive sequence of positive integers of
length \(N\), for example \(n=1,2,\ldots,N\). Now choose any prime
number \(p\) and convert each integer \(n\) into its representation in
the base \(p\) number system. For multiple dimensions, repeat the
process with a different prime \(p\). Then reflect the base \(p\)
representation of each integer about the decimal point to obtain a
number in the interval \([0,1)\).

Many other techniques exist for creating low-discrepancy sequences.
Faure' sequences are permutations of Halton sequences. Sobol sequences
are a reordering of Halton sequences. Other methods include
\((t,m,s)\)-Nets and the method of good lattice points. Niederreiter
(1978) is a good resource on low-discrepancy sequences in quasi-Monte
Carlo methods.

Quasi-Monte Carlo methods do far better asymptotically than any Monte
Carlo method for many problems. With \(N\) points in \(s\) dimensions,
quasi-Monte Carlo techniques have a worst-case convergence rate of
\(O \left( \frac{\left( \log N\right) ^s}{N} \right)\) as opposed to
\(O \left( \frac{1}{\sqrt{N}} \right)\) for standard Monte Carlo
techniques. However, standard Monte Carlo integration is easier to
implement properly and is generally sufficient for most purposes.

    \subsubsection{4.3. Exercises}\label{exercises}

    \textbf{Exercise 4.1.} Use Monte Carlo integration to approximate the
value of \(\pi\). Define a function in that takes as arguments a
function \(g(\mathbf{x})\) of a vector of variables \(\mathbf{x}\), the
domain \(\Omega\) of \(\mathbf{x}\), and the number of random draws
\(N\) and returns the Monte Carlo approximation of the integral
\(\int_\Omega g(\mathbf{x}) d\mathbf{x}\). Let \(\Omega\) be a
generalized rectangle-\/-width \(x\) and height \(y\). In order to
approximate \(\pi\), let the functional form of the anonymous function
be \(g(x,y)\) from Section 4.1 with domain
\(\Omega = [-1,1]\times[-1,1]\). What is the smallest number of random
draws \(N\) from \(\Omega\) that matches the true value of \(\pi\) to
the 4th decimal 3.1415? Set the random seed in your uniform random
number generator to 25. This will make the correct answer consistent
across submissions.

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}22}]:} \PY{n}{np}\PY{o}{.}\PY{n}{random}\PY{o}{.}\PY{n}{seed}\PY{o}{=}\PY{l+m+mi}{25}
         \PY{k}{def} \PY{n+nf}{MC}\PY{p}{(}\PY{n}{g}\PY{p}{,}\PY{n}{omega}\PY{p}{,}\PY{n}{N}\PY{p}{)}\PY{p}{:}
             \PY{n}{x\PYZus{}l}\PY{p}{,}\PY{n}{x\PYZus{}r} \PY{o}{=} \PY{n}{omega}\PY{p}{[}\PY{l+m+mi}{0}\PY{p}{]}\PY{p}{[}\PY{l+m+mi}{0}\PY{p}{]}\PY{p}{,}\PY{n}{omega}\PY{p}{[}\PY{l+m+mi}{0}\PY{p}{]}\PY{p}{[}\PY{l+m+mi}{1}\PY{p}{]}
             \PY{n}{y\PYZus{}l}\PY{p}{,}\PY{n}{y\PYZus{}r}\PY{o}{=} \PY{n}{omega}\PY{p}{[}\PY{l+m+mi}{1}\PY{p}{]}\PY{p}{[}\PY{l+m+mi}{0}\PY{p}{]}\PY{p}{,}\PY{n}{omega}\PY{p}{[}\PY{l+m+mi}{1}\PY{p}{]}\PY{p}{[}\PY{l+m+mi}{1}\PY{p}{]}
             \PY{n}{xrange} \PY{o}{=} \PY{n}{np}\PY{o}{.}\PY{n}{random}\PY{o}{.}\PY{n}{uniform}\PY{p}{(}\PY{n}{x\PYZus{}l}\PY{p}{,}\PY{n}{x\PYZus{}r}\PY{p}{,}\PY{n}{N}\PY{p}{)}
             \PY{n}{yrange} \PY{o}{=} \PY{n}{np}\PY{o}{.}\PY{n}{random}\PY{o}{.}\PY{n}{uniform}\PY{p}{(}\PY{n}{y\PYZus{}l}\PY{p}{,}\PY{n}{y\PYZus{}r}\PY{p}{,}\PY{n}{N}\PY{p}{)}
             \PY{n}{arr} \PY{o}{=} \PY{p}{[}\PY{n}{g}\PY{p}{(}\PY{n}{xrange}\PY{p}{[}\PY{n}{i}\PY{p}{]}\PY{p}{,}\PY{n}{yrange}\PY{p}{[}\PY{n}{i}\PY{p}{]}\PY{p}{)} \PY{k}{for} \PY{n}{i} \PY{o+ow}{in} \PY{n+nb}{range}\PY{p}{(}\PY{n}{N}\PY{p}{)}\PY{p}{]}
             \PY{n}{inside} \PY{o}{=} \PY{n+nb}{sum}\PY{p}{(}\PY{n}{arr}\PY{p}{)}
             \PY{n}{area} \PY{o}{=} \PY{p}{(}\PY{n}{x\PYZus{}r}\PY{o}{\PYZhy{}}\PY{n}{x\PYZus{}l}\PY{p}{)}\PY{o}{*}\PY{p}{(}\PY{n}{y\PYZus{}r}\PY{o}{\PYZhy{}}\PY{n}{y\PYZus{}l}\PY{p}{)}
             \PY{k}{return} \PY{n}{area} \PY{o}{*} \PY{n}{inside} \PY{o}{/} \PY{n}{N}
         
         \PY{k}{def} \PY{n+nf}{g}\PY{p}{(}\PY{n}{x}\PY{p}{,}\PY{n}{y}\PY{p}{)}\PY{p}{:}
             \PY{k}{if} \PY{n}{x}\PY{o}{*}\PY{o}{*}\PY{l+m+mi}{2}\PY{o}{+}\PY{n}{y}\PY{o}{*}\PY{o}{*}\PY{l+m+mi}{2}\PY{o}{\PYZlt{}}\PY{l+m+mi}{1}\PY{p}{:}
                 \PY{k}{return} \PY{l+m+mi}{1}
             \PY{k}{else}\PY{p}{:}
                 \PY{k}{return} \PY{l+m+mi}{0}
         \PY{n}{omega}\PY{o}{=}\PY{n}{np}\PY{o}{.}\PY{n}{array}\PY{p}{(}\PY{p}{[}\PY{p}{[}\PY{o}{\PYZhy{}}\PY{l+m+mi}{1}\PY{p}{,}\PY{l+m+mi}{1}\PY{p}{]}\PY{p}{,}\PY{p}{[}\PY{o}{\PYZhy{}}\PY{l+m+mi}{1}\PY{p}{,}\PY{l+m+mi}{1}\PY{p}{]}\PY{p}{]}\PY{p}{)}
         \PY{n}{MC}\PY{p}{(}\PY{n}{g}\PY{p}{,}\PY{n}{omega}\PY{p}{,}\PY{l+m+mi}{10000}\PY{p}{)}
\end{Verbatim}


\begin{Verbatim}[commandchars=\\\{\}]
{\color{outcolor}Out[{\color{outcolor}22}]:} 3.1552
\end{Verbatim}
            
    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}23}]:} \PY{n}{i}\PY{o}{=}\PY{l+m+mi}{1}
         \PY{k}{while} \PY{n+nb}{round}\PY{p}{(}\PY{n}{MC}\PY{p}{(}\PY{n}{g}\PY{p}{,}\PY{n}{omega}\PY{p}{,}\PY{n}{i}\PY{p}{)}\PY{p}{,}\PY{l+m+mi}{4}\PY{p}{)}\PY{o}{!=}\PY{l+m+mf}{3.1415}\PY{p}{:}
             \PY{n}{i}\PY{o}{+}\PY{o}{=}\PY{l+m+mi}{1}
         \PY{k}{else}\PY{p}{:}
             \PY{n+nb}{print}\PY{p}{(}\PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{Smallest number of random draws N from : }\PY{l+s+s2}{\PYZdq{}}\PY{p}{,}\PY{n}{i}\PY{p}{)}
\end{Verbatim}


    \begin{Verbatim}[commandchars=\\\{\}]
Smallest number of random draws N from :  1039

    \end{Verbatim}

    \textbf{Exercise 4.2.} Define a function in that returns the \(n\)-th
element of a \(d\)-dimensional equidistributed sequence. It should have
support for the four sequences in the Table in Section 4.2.

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}24}]:} \PY{k}{def} \PY{n+nf}{equidis}\PY{p}{(}\PY{n}{n}\PY{p}{,}\PY{n}{d}\PY{p}{,}\PY{n}{Type}\PY{p}{)}\PY{p}{:}
             \PY{n}{prime} \PY{o}{=} \PY{n}{primes\PYZus{}ascend}\PY{p}{(}\PY{n}{d}\PY{p}{)}
             \PY{k}{if} \PY{n}{Type} \PY{o}{==} \PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{Weyl}\PY{l+s+s1}{\PYZsq{}}\PY{p}{:}
                 \PY{k}{return} \PY{n+nb}{list}\PY{p}{(}\PY{p}{(}\PY{n}{i} \PY{o}{\PYZhy{}} \PY{n}{i} \PY{o}{/}\PY{o}{/} \PY{l+m+mi}{1}\PY{p}{)} \PY{k}{for} \PY{n}{i} \PY{o+ow}{in} \PY{n}{np}\PY{o}{.}\PY{n}{sqrt}\PY{p}{(}\PY{n}{prime}\PY{p}{)}\PY{o}{*}\PY{n}{n}\PY{p}{)}
             \PY{k}{elif} \PY{n}{Type} \PY{o}{==} \PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{Haber}\PY{l+s+s1}{\PYZsq{}}\PY{p}{:}
                 \PY{k}{return} \PY{n+nb}{list}\PY{p}{(}\PY{p}{(}\PY{n}{i} \PY{o}{\PYZhy{}} \PY{n}{i} \PY{o}{/}\PY{o}{/} \PY{l+m+mi}{1}\PY{p}{)} \PY{k}{for} \PY{n}{i} \PY{o+ow}{in} \PY{n}{np}\PY{o}{.}\PY{n}{sqrt}\PY{p}{(}\PY{n}{prime}\PY{p}{)}\PY{o}{*}\PY{n}{n}\PY{o}{*}\PY{p}{(}\PY{n}{n}\PY{o}{+}\PY{l+m+mi}{1}\PY{p}{)}\PY{o}{/}\PY{l+m+mi}{2}\PY{p}{)}
             \PY{k}{elif} \PY{n}{Type} \PY{o}{==} \PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{Niederreiter}\PY{l+s+s1}{\PYZsq{}}\PY{p}{:}
                 \PY{k}{return} \PY{n+nb}{list}\PY{p}{(}\PY{p}{(}\PY{n}{i} \PY{o}{\PYZhy{}} \PY{n}{i} \PY{o}{/}\PY{o}{/} \PY{l+m+mi}{1}\PY{p}{)} \PY{k}{for} \PY{n}{i} \PY{o+ow}{in} \PY{p}{[}\PY{n}{n}\PY{o}{*}\PY{p}{(}\PY{l+m+mi}{2}\PY{o}{*}\PY{o}{*}\PY{p}{(}\PY{n}{j}\PY{o}{/}\PY{p}{(}\PY{n}{n}\PY{o}{+}\PY{l+m+mi}{1}\PY{p}{)}\PY{p}{)}\PY{p}{)} \PY{k}{for} \PY{n}{j} \PY{o+ow}{in} \PY{n+nb}{range}\PY{p}{(}\PY{l+m+mi}{1}\PY{p}{,} \PY{n}{d}\PY{o}{+}\PY{l+m+mi}{1}\PY{p}{)}\PY{p}{]}\PY{p}{)}
             \PY{k}{elif} \PY{n}{Type} \PY{o}{==} \PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{Baker}\PY{l+s+s1}{\PYZsq{}}\PY{p}{:}
                 \PY{k}{return} \PY{n+nb}{list}\PY{p}{(}\PY{p}{(}\PY{n}{i} \PY{o}{\PYZhy{}} \PY{n}{i} \PY{o}{/}\PY{o}{/} \PY{l+m+mi}{1}\PY{p}{)} \PY{k}{for} \PY{n}{i} \PY{o+ow}{in} \PY{p}{[}\PY{n}{n}\PY{o}{*}\PY{n}{np}\PY{o}{.}\PY{n}{exp}\PY{p}{(}\PY{l+m+mi}{1}\PY{o}{/}\PY{n}{j}\PY{p}{)} \PY{k}{for} \PY{n}{j} \PY{o+ow}{in} \PY{n+nb}{range}\PY{p}{(}\PY{l+m+mi}{1}\PY{p}{,} \PY{n}{d}\PY{o}{+}\PY{l+m+mi}{1}\PY{p}{)}\PY{p}{]}\PY{p}{)}
\end{Verbatim}


    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}25}]:} \PY{n}{equidis}\PY{p}{(}\PY{l+m+mi}{10}\PY{p}{,} \PY{l+m+mi}{4}\PY{p}{,} \PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{Weyl}\PY{l+s+s1}{\PYZsq{}}\PY{p}{)}
\end{Verbatim}


\begin{Verbatim}[commandchars=\\\{\}]
{\color{outcolor}Out[{\color{outcolor}25}]:} [0.142135623730951,
          0.32050807568877104,
          0.36067977499789805,
          0.4575131106459054]
\end{Verbatim}
            
    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}26}]:} \PY{n}{equidis}\PY{p}{(}\PY{l+m+mi}{10}\PY{p}{,} \PY{l+m+mi}{4}\PY{p}{,} \PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{Haber}\PY{l+s+s1}{\PYZsq{}}\PY{p}{)}
\end{Verbatim}


\begin{Verbatim}[commandchars=\\\{\}]
{\color{outcolor}Out[{\color{outcolor}26}]:} [0.7817459305202306,
          0.2627944162882443,
          0.9837387624884428,
          0.5163221085524867]
\end{Verbatim}
            
    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}27}]:} \PY{n}{equidis}\PY{p}{(}\PY{l+m+mi}{10}\PY{p}{,} \PY{l+m+mi}{4}\PY{p}{,} \PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{Niederreiter}\PY{l+s+s1}{\PYZsq{}}\PY{p}{)}
\end{Verbatim}


\begin{Verbatim}[commandchars=\\\{\}]
{\color{outcolor}Out[{\color{outcolor}27}]:} [0.6504108943996272,
          0.3431252219546259,
          0.08089444404447121,
          0.8666489800943182]
\end{Verbatim}
            
    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}28}]:} \PY{n}{equidis}\PY{p}{(}\PY{l+m+mi}{10}\PY{p}{,} \PY{l+m+mi}{4}\PY{p}{,} \PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{Baker}\PY{l+s+s1}{\PYZsq{}}\PY{p}{)}
\end{Verbatim}


\begin{Verbatim}[commandchars=\\\{\}]
{\color{outcolor}Out[{\color{outcolor}28}]:} [0.18281828459045002,
          0.4872127070012837,
          0.9561242508608956,
          0.8402541668774148]
\end{Verbatim}
            
    \textbf{Exercise 4.3} Repeat Exercise 4.1 to approximate the value of
\(\pi\), this time using quasi-Monte Carlo integration. You will need to
appropriately scale the equidistributed sequences. Compare the rates of
convergence. What is the smallest number of random draws \(N\) from
\(\Omega\) for the quasi-Monte Carlo integration that matches the true
value of \(\pi\) to the 4th decimal 3.1415?. Set the seed in your
uniform random number generator to 25. This will make the correct answer
consistent across submissions.

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}29}]:} \PY{k+kn}{import} \PY{n+nn}{random}
         \PY{n}{random}\PY{o}{.}\PY{n}{seed}\PY{p}{(}\PY{l+m+mi}{25}\PY{p}{)}
         \PY{k}{def} \PY{n+nf}{QMC}\PY{p}{(}\PY{n}{fn}\PY{p}{,} \PY{n}{omega}\PY{p}{,} \PY{n}{N}\PY{p}{,} \PY{n}{Type}\PY{p}{)}\PY{p}{:}
             \PY{n}{x1}\PY{p}{,} \PY{n}{x2}\PY{o}{=}\PY{n}{omega}\PY{p}{[}\PY{l+m+mi}{0}\PY{p}{]}\PY{p}{,}\PY{n}{omega}\PY{p}{[}\PY{l+m+mi}{1}\PY{p}{]} 
             \PY{n}{y1}\PY{p}{,} \PY{n}{y2}\PY{o}{=}\PY{n}{omega}\PY{p}{[}\PY{l+m+mi}{2}\PY{p}{]}\PY{p}{,}\PY{n}{omega}\PY{p}{[}\PY{l+m+mi}{3}\PY{p}{]}
             \PY{k}{if} \PY{n}{Type}\PY{o}{==}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{Weyl}\PY{l+s+s1}{\PYZsq{}}\PY{p}{:}
                 \PY{n}{xran}\PY{o}{=}\PY{p}{[}\PY{l+m+mi}{2}\PY{o}{*}\PY{n}{np}\PY{o}{.}\PY{n}{array}\PY{p}{(}\PY{n}{equidis}\PY{p}{(}\PY{n}{i}\PY{p}{,}\PY{l+m+mi}{2}\PY{p}{,}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{Weyl}\PY{l+s+s1}{\PYZsq{}}\PY{p}{)}\PY{p}{)}\PY{p}{[}\PY{l+m+mi}{0}\PY{p}{]}\PY{o}{\PYZhy{}}\PY{l+m+mi}{1} \PY{k}{for} \PY{n}{i} \PY{o+ow}{in} \PY{n+nb}{range}\PY{p}{(}\PY{n}{N}\PY{p}{)}\PY{p}{]} 
                 \PY{n}{yran}\PY{o}{=}\PY{p}{[}\PY{l+m+mi}{2}\PY{o}{*}\PY{n}{np}\PY{o}{.}\PY{n}{array}\PY{p}{(}\PY{n}{equidis}\PY{p}{(}\PY{n}{i}\PY{p}{,}\PY{l+m+mi}{2}\PY{p}{,}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{Weyl}\PY{l+s+s1}{\PYZsq{}}\PY{p}{)}\PY{p}{)}\PY{p}{[}\PY{l+m+mi}{1}\PY{p}{]}\PY{o}{\PYZhy{}}\PY{l+m+mi}{1} \PY{k}{for} \PY{n}{i} \PY{o+ow}{in} \PY{n+nb}{range}\PY{p}{(}\PY{n}{N}\PY{p}{)}\PY{p}{]}
             \PY{k}{elif} \PY{n}{Type}\PY{o}{==}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{Haber}\PY{l+s+s1}{\PYZsq{}}\PY{p}{:} 
                 \PY{n}{xran}\PY{o}{=}\PY{p}{[}\PY{l+m+mi}{2}\PY{o}{*}\PY{n}{np}\PY{o}{.}\PY{n}{array}\PY{p}{(}\PY{n}{equidis}\PY{p}{(}\PY{n}{i}\PY{p}{,}\PY{l+m+mi}{2}\PY{p}{,}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{Haber}\PY{l+s+s1}{\PYZsq{}}\PY{p}{)}\PY{p}{)}\PY{p}{[}\PY{l+m+mi}{0}\PY{p}{]}\PY{o}{\PYZhy{}}\PY{l+m+mi}{1} \PY{k}{for} \PY{n}{i} \PY{o+ow}{in} \PY{n+nb}{range}\PY{p}{(}\PY{n}{N}\PY{p}{)}\PY{p}{]} 
                 \PY{n}{yran}\PY{o}{=}\PY{p}{[}\PY{l+m+mi}{2}\PY{o}{*}\PY{n}{np}\PY{o}{.}\PY{n}{array}\PY{p}{(}\PY{n}{equidis}\PY{p}{(}\PY{n}{i}\PY{p}{,}\PY{l+m+mi}{2}\PY{p}{,}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{Haber}\PY{l+s+s1}{\PYZsq{}}\PY{p}{)}\PY{p}{)}\PY{p}{[}\PY{l+m+mi}{1}\PY{p}{]}\PY{o}{\PYZhy{}}\PY{l+m+mi}{1} \PY{k}{for} \PY{n}{i} \PY{o+ow}{in} \PY{n+nb}{range}\PY{p}{(}\PY{n}{N}\PY{p}{)}\PY{p}{]}
             \PY{k}{elif} \PY{n}{Type}\PY{o}{==}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{Niederreiter}\PY{l+s+s1}{\PYZsq{}}\PY{p}{:} 
                 \PY{n}{xran}\PY{o}{=}\PY{p}{[}\PY{l+m+mi}{2}\PY{o}{*}\PY{n}{np}\PY{o}{.}\PY{n}{array}\PY{p}{(}\PY{n}{equidis}\PY{p}{(}\PY{n}{i}\PY{p}{,}\PY{l+m+mi}{2}\PY{p}{,}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{Niederreiter}\PY{l+s+s1}{\PYZsq{}}\PY{p}{)}\PY{p}{)}\PY{p}{[}\PY{l+m+mi}{0}\PY{p}{]}\PY{o}{\PYZhy{}}\PY{l+m+mi}{1} \PY{k}{for} \PY{n}{i} \PY{o+ow}{in} \PY{n+nb}{range}\PY{p}{(}\PY{n}{N}\PY{p}{)}\PY{p}{]}
                 \PY{n}{yran}\PY{o}{=}\PY{p}{[}\PY{l+m+mi}{2}\PY{o}{*}\PY{n}{np}\PY{o}{.}\PY{n}{array}\PY{p}{(}\PY{n}{equidis}\PY{p}{(}\PY{n}{i}\PY{p}{,}\PY{l+m+mi}{2}\PY{p}{,}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{Niederreiter}\PY{l+s+s1}{\PYZsq{}}\PY{p}{)}\PY{p}{)}\PY{p}{[}\PY{l+m+mi}{1}\PY{p}{]}\PY{o}{\PYZhy{}}\PY{l+m+mi}{1} \PY{k}{for} \PY{n}{i} \PY{o+ow}{in} \PY{n+nb}{range}\PY{p}{(}\PY{n}{N}\PY{p}{)}\PY{p}{]} 
             \PY{k}{elif} \PY{n}{Type}\PY{o}{==}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{Baker}\PY{l+s+s1}{\PYZsq{}}\PY{p}{:}
                 \PY{n}{xran}\PY{o}{=}\PY{p}{[}\PY{l+m+mi}{2}\PY{o}{*}\PY{n}{np}\PY{o}{.}\PY{n}{array}\PY{p}{(}\PY{n}{equidis}\PY{p}{(}\PY{n}{i}\PY{p}{,}\PY{l+m+mi}{2}\PY{p}{,}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{Baker}\PY{l+s+s1}{\PYZsq{}}\PY{p}{)}\PY{p}{)}\PY{p}{[}\PY{l+m+mi}{0}\PY{p}{]}\PY{o}{\PYZhy{}}\PY{l+m+mi}{1} \PY{k}{for} \PY{n}{i} \PY{o+ow}{in} \PY{n+nb}{range}\PY{p}{(}\PY{n}{N}\PY{p}{)}\PY{p}{]}
                 \PY{n}{yran}\PY{o}{=}\PY{p}{[}\PY{l+m+mi}{2}\PY{o}{*}\PY{n}{np}\PY{o}{.}\PY{n}{array}\PY{p}{(}\PY{n}{equidis}\PY{p}{(}\PY{n}{i}\PY{p}{,}\PY{l+m+mi}{2}\PY{p}{,}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{Baker}\PY{l+s+s1}{\PYZsq{}}\PY{p}{)}\PY{p}{)}\PY{p}{[}\PY{l+m+mi}{1}\PY{p}{]}\PY{o}{\PYZhy{}}\PY{l+m+mi}{1} \PY{k}{for} \PY{n}{i} \PY{o+ow}{in} \PY{n+nb}{range}\PY{p}{(}\PY{n}{N}\PY{p}{)}\PY{p}{]}
             \PY{n}{counter} \PY{o}{=} \PY{l+m+mi}{0}
             \PY{k}{for} \PY{n}{i} \PY{o+ow}{in} \PY{n+nb}{range}\PY{p}{(}\PY{n}{N}\PY{p}{)}\PY{p}{:}
                 \PY{n}{x} \PY{o}{=} \PY{n}{xran}\PY{p}{[}\PY{n}{i}\PY{p}{]}
                 \PY{n}{y} \PY{o}{=} \PY{n}{yran}\PY{p}{[}\PY{n}{i}\PY{p}{]}
                 \PY{n}{counter} \PY{o}{+}\PY{o}{=} \PY{n}{fn}\PY{p}{(}\PY{n}{x}\PY{p}{,} \PY{n}{y}\PY{p}{)}
             \PY{n}{area} \PY{o}{=} \PY{p}{(}\PY{n}{omega}\PY{p}{[}\PY{l+m+mi}{1}\PY{p}{]} \PY{o}{\PYZhy{}} \PY{n}{omega}\PY{p}{[}\PY{l+m+mi}{0}\PY{p}{]}\PY{p}{)}\PY{o}{*}\PY{p}{(}\PY{n}{omega}\PY{p}{[}\PY{l+m+mi}{3}\PY{p}{]} \PY{o}{\PYZhy{}} \PY{n}{omega}\PY{p}{[}\PY{l+m+mi}{2}\PY{p}{]}\PY{p}{)}
             \PY{k}{return} \PY{n}{area}\PY{o}{*}\PY{n}{counter}\PY{o}{/}\PY{n}{N}
\end{Verbatim}


    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}30}]:} \PY{k}{def} \PY{n+nf}{f}\PY{p}{(}\PY{n}{x}\PY{p}{,} \PY{n}{y}\PY{p}{)}\PY{p}{:}
                 \PY{k}{if} \PY{n}{x} \PY{o}{*}\PY{o}{*} \PY{l+m+mi}{2} \PY{o}{+} \PY{n}{y} \PY{o}{*}\PY{o}{*} \PY{l+m+mi}{2} \PY{o}{\PYZlt{}}\PY{o}{=} \PY{l+m+mi}{1}\PY{p}{:}
                     \PY{k}{return} \PY{l+m+mi}{1}
                 \PY{k}{else}\PY{p}{:}
                     \PY{k}{return} \PY{l+m+mi}{0}
         
         
         \PY{n}{N} \PY{o}{=} \PY{l+m+mi}{1}
         \PY{k}{while} \PY{n+nb}{round}\PY{p}{(}\PY{n}{QMC}\PY{p}{(}\PY{n}{f}\PY{p}{,} \PY{p}{[}\PY{o}{\PYZhy{}}\PY{l+m+mi}{1}\PY{p}{,} \PY{l+m+mi}{1}\PY{p}{,} \PY{o}{\PYZhy{}}\PY{l+m+mi}{1}\PY{p}{,} \PY{l+m+mi}{1}\PY{p}{]}\PY{p}{,} \PY{n}{N}\PY{p}{,} \PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{Weyl}\PY{l+s+s2}{\PYZdq{}}\PY{p}{)}\PY{p}{,}\PY{l+m+mi}{4}\PY{p}{)} \PY{o}{!=} \PY{l+m+mf}{3.1415}\PY{p}{:}
             \PY{n}{N} \PY{o}{+}\PY{o}{=} \PY{l+m+mi}{1}
         \PY{n+nb}{print}\PY{p}{(}\PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{The smallest number of random draws N with Weyl sequence is}\PY{l+s+s2}{\PYZdq{}}\PY{p}{,} \PY{n}{N}\PY{p}{)}
\end{Verbatim}


    \begin{Verbatim}[commandchars=\\\{\}]
The smallest number of random draws N with Weyl sequence is 1230

    \end{Verbatim}

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}31}]:} \PY{n}{N} \PY{o}{=} \PY{l+m+mi}{1}
         \PY{k}{while} \PY{n+nb}{round}\PY{p}{(}\PY{n}{QMC}\PY{p}{(}\PY{n}{f}\PY{p}{,} \PY{p}{[}\PY{o}{\PYZhy{}}\PY{l+m+mi}{1}\PY{p}{,} \PY{l+m+mi}{1}\PY{p}{,} \PY{o}{\PYZhy{}}\PY{l+m+mi}{1}\PY{p}{,} \PY{l+m+mi}{1}\PY{p}{]}\PY{p}{,} \PY{n}{N}\PY{p}{,} \PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{Haber}\PY{l+s+s2}{\PYZdq{}}\PY{p}{)}\PY{p}{,}\PY{l+m+mi}{4}\PY{p}{)} \PY{o}{!=} \PY{l+m+mf}{3.1415}\PY{p}{:}
             \PY{n}{N} \PY{o}{+}\PY{o}{=} \PY{l+m+mi}{1}
             
         \PY{n+nb}{print}\PY{p}{(}\PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{The smallest number of random draws N with Haber sequence is}\PY{l+s+s2}{\PYZdq{}}\PY{p}{,} \PY{n}{N}\PY{p}{)}
\end{Verbatim}


    \begin{Verbatim}[commandchars=\\\{\}]
The smallest number of random draws N with Haber sequence is 2064

    \end{Verbatim}

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}36}]:} \PY{n}{N} \PY{o}{=} \PY{l+m+mi}{1}
         \PY{k}{while} \PY{n+nb}{round}\PY{p}{(}\PY{n}{QMC}\PY{p}{(}\PY{n}{f}\PY{p}{,} \PY{p}{[}\PY{o}{\PYZhy{}}\PY{l+m+mi}{1}\PY{p}{,} \PY{l+m+mi}{1}\PY{p}{,} \PY{o}{\PYZhy{}}\PY{l+m+mi}{1}\PY{p}{,} \PY{l+m+mi}{1}\PY{p}{]}\PY{p}{,} \PY{n}{N}\PY{p}{,} \PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{Niederreiter}\PY{l+s+s2}{\PYZdq{}}\PY{p}{)}\PY{p}{,}\PY{l+m+mi}{4}\PY{p}{)} \PY{o}{!=} \PY{l+m+mf}{3.1415}\PY{p}{:}
             \PY{n}{N} \PY{o}{+}\PY{o}{=} \PY{l+m+mi}{1}
             \PY{k}{if} \PY{n}{N} \PY{o}{\PYZgt{}} \PY{l+m+mi}{3000}\PY{p}{:}
                 \PY{n+nb}{print}\PY{p}{(}\PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{The smallest number of random draws N with Niederreiter sequence exceeds 3000.}\PY{l+s+s2}{\PYZdq{}}\PY{p}{)}
                 \PY{k}{break}
         \PY{k}{else}\PY{p}{:}
             \PY{n+nb}{print}\PY{p}{(}\PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{The smallest number of random draws N with Niederreiter sequence is}\PY{l+s+s2}{\PYZdq{}}\PY{p}{,} \PY{n}{N}\PY{p}{)}
\end{Verbatim}


    \begin{Verbatim}[commandchars=\\\{\}]
The smallest number of random draws N with Niederreiter sequence exceeds 3000.

    \end{Verbatim}

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}35}]:} \PY{n}{N} \PY{o}{=} \PY{l+m+mi}{1}
         \PY{k}{while} \PY{n+nb}{round}\PY{p}{(}\PY{n}{QMC}\PY{p}{(}\PY{n}{f}\PY{p}{,} \PY{p}{[}\PY{o}{\PYZhy{}}\PY{l+m+mi}{1}\PY{p}{,} \PY{l+m+mi}{1}\PY{p}{,} \PY{o}{\PYZhy{}}\PY{l+m+mi}{1}\PY{p}{,} \PY{l+m+mi}{1}\PY{p}{]}\PY{p}{,} \PY{n}{N}\PY{p}{,} \PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{Baker}\PY{l+s+s2}{\PYZdq{}}\PY{p}{)}\PY{p}{,}\PY{l+m+mi}{4}\PY{p}{)} \PY{o}{!=} \PY{l+m+mf}{3.1415}\PY{p}{:}
             \PY{n}{N} \PY{o}{+}\PY{o}{=} \PY{l+m+mi}{1}
             
         \PY{n+nb}{print}\PY{p}{(}\PY{l+s+s2}{\PYZdq{}}\PY{l+s+s2}{The smallest number of random draws N with Baker sequence is}\PY{l+s+s2}{\PYZdq{}}\PY{p}{,} \PY{n}{N}\PY{p}{)}
\end{Verbatim}


    \begin{Verbatim}[commandchars=\\\{\}]
The smallest number of random draws N with Baker sequence is 205

    \end{Verbatim}

    From the results, we could see that the ranking of the rate of
convergence is:

1.Baker sequence 2. Weyl sequence 3. Haber sequence 4.Niederreiter
sequence

    \subsection{5. Sparse Grids}\label{sparse-grids}

Sparse grid interpolation is a method of approximating functions with
many dimensions. A direct way of representing multidimensional functions
is to use a full grid, such as in Newton-Cotes quadrature. However,
using this method the number of grid points that have to be computed
depends exponentially on the number of dimensions. Because of this curse
of dimensionality, processing functions of beyond five or six dimensions
becomes intractable using the techniques of Sections 2 and 3. While
Monte Carlo methods perform reasonably well in multidimensional
integration, sparse grids remain the most efficient.

The sparse grid method selects the nodes of integration by a special
truncation of the tensor product expansion of a one-dimensional
multilevel selection of nodes. To construct a sparse grid, we first
select a series of one-dimensional quadrature formulas indexed by \(l\)
for a univariate function \(f\), and write it as

\begin{equation}\label{EqSGQuad}
  Q_l^{(1)}f = \sum_{i=1}^{N_l}w_{li}f(x_{li}).
\end{equation}

For example, the nodes and weights of this initial quadrature formula
series could be based on the trapezoid rule or Simpson's rule with
\(N_l\) nodes. Now define the difference formulas by,

\begin{equation}\label{EqSGDiff}
  \Delta_k^{(1)}f = (Q_k^{(1)}-Q_{k-1}^{(1)})f
\end{equation}

where \(Q_0^{(1)}f=0\). Note that the differences \(\Delta_k^{(1)}f\)
are just univariate quadrature formulas.

For a given level \(l\in \mathbb{N}\), the sparse gride integration
approximation for a \(d\)-dimensional function \(f\) is given by

\begin{equation}\label{EqSGSparseGrid}
  Q_l^{(d)} = \sum_{||\mathbf{k}||\leq l+d-1}(\Delta_{k_1}^{(1)}\otimes \ldots \otimes \Delta_{k_d}^{(1)})f.
\end{equation}

Using the quadrature rule in the equation above, every possible tensor
product of the difference formulas is considered, but only those whose
sum of indices is smaller than the constant \(l+d-1\) are used.

The selcetion of nodes in a two-dimensional sparse grid of level \(l=3\)
using the trapezoid rule as the intial formula is visualized in the
figure below. Along the top and left are the one-dimensional grid points
for \(l=1,2,3\) in the \(x\)- and \(y\)-directions. These points are
used to create the corresponding product grids
\(\Delta_{k_1}\otimes\Delta_{k_2}\) for \(1\leq k_1,k_2\leq3\). Because
the grid points used in the trapezoid rule are nested, many of the grid
points are cancelled out, and the only ones that remain are formed from
a union of the grids along the diagonal as indicated by the black line.
The resulting sparse grid \(Q_3^{(2)}\) is shown on the right.

    \begin{Verbatim}[commandchars=\\\{\}]
{\color{incolor}In [{\color{incolor}34}]:} \PY{c+c1}{\PYZsh{} Download and save the data file NumInt\PYZus{}TrapezoidGrid.png}
         \PY{n}{url} \PY{o}{=} \PY{p}{(}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{https://raw.githubusercontent.com/rickecon/Notebooks/}\PY{l+s+s1}{\PYZsq{}} \PY{o}{+}
                \PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{master/NumIntegr/images/NumInt\PYZus{}TrapezoidGrid.png}\PY{l+s+s1}{\PYZsq{}}\PY{p}{)}
         \PY{n}{image\PYZus{}file} \PY{o}{=} \PY{n}{requests}\PY{o}{.}\PY{n}{get}\PY{p}{(}\PY{n}{url}\PY{p}{,} \PY{n}{allow\PYZus{}redirects}\PY{o}{=}\PY{k+kc}{True}\PY{p}{)}
         \PY{n+nb}{open}\PY{p}{(}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{NumInt\PYZus{}TrapezoidGrid.png}\PY{l+s+s1}{\PYZsq{}}\PY{p}{,} \PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{wb}\PY{l+s+s1}{\PYZsq{}}\PY{p}{)}\PY{o}{.}\PY{n}{write}\PY{p}{(}\PY{n}{image\PYZus{}file}\PY{o}{.}\PY{n}{content}\PY{p}{)}
         \PY{n}{Image}\PY{p}{(}\PY{l+s+s1}{\PYZsq{}}\PY{l+s+s1}{NumInt\PYZus{}TrapezoidGrid.png}\PY{l+s+s1}{\PYZsq{}}\PY{p}{)}
\end{Verbatim}

\texttt{\color{outcolor}Out[{\color{outcolor}34}]:}
    
    \begin{center}
    \adjustimage{max size={0.9\linewidth}{0.9\paperheight}}{output_66_0.png}
    \end{center}
    { \hspace*{\fill} \\}
    

    \subsection{6. Discrete Markov Approximation of Continuous AR(1)
Process}\label{discrete-markov-approximation-of-continuous-ar1-process}

Suppose you have a random shock \(z_t\) in your model that has some
persistence according to the following AR(1) process.

\begin{equation}\label{NumInt_EqAR1}
  z_{t+1} = \rho z_{t} + (1-\rho)\mu + \varepsilon_{t+1} \quad\text{where}\quad \varepsilon_t\sim N(0,\sigma) \quad\text{and}\quad \rho\in(0,1)
\end{equation}

The expected value of \(z_{t+1}\) is conditional on the current
realization of the shock \(E[z_{t+1}|z_t] = \rho z_{t} + (1-\rho)\mu\)
but the variance of \(z_{t+1}\) is unconditional
\(Var[z_{t+1}] = \sigma^2\). The AR(1) process in this equation
generates a variable that fluctuates around its mean \(\mu\), and the
expected value of the variable tomorrow \(E[z_{t+1}|z_t]\) is some
convex combination of the variable today \(z_t\) and the mean \(\mu\).

Typical examples of these types of shocks in economics are shocks to
ability, health status, and productivity shocks-\/-all of which exhibit
persistence or dependence on recent values. If the shock must be
strictly positive, as is the case with productivity shocks, the variable
\(z_t\) is simply exponentiated.

\begin{equation}\label{NumInt_EqStochProd}
  Y_t = A_t K_t^\alpha L_t^{1-\alpha} \quad\text{where}\quad A_t = e^{z_t}
\end{equation}

Notice that the variable \(A_t\) is lognormally distributed
\(A_t\sim LN\bigl(\rho z_{t-1} + (1-\rho)\mu,\sigma\bigr)\) because
\(\log(A_t)=z_t\) and
\(z_t\sim N\bigl(\rho z_{t-1} + (1-\rho)\mu,\sigma\bigr)\). You made a
discretized approximation of the i.i.d. (no persistence) version of this
distribution in Exercise 2.3 and estimated average income in the U.S.
using it in Exercise 2.4.

Tauchen and Hussey (1991) describe a quadrature-based method for
producing efficient nodes and probabilities of a discrete first-order
Markov process to approximate a continuous AR(1) random variable.
Tauchen (1986) details a simpler non-quadrature based method for
producing efficient nodes and probabilities of a discrete first-order
Markov process to approximate a continuous AR(1) random variable. A
classic example of where this discretization is extremely valuable is in
the stochastic intertemporal Euler equation from Section 1.

\begin{equation}\tag{\ref{NumInt_EqEulEx}}
  \begin{split}
    u'(c_t) &^= \beta E_{z_{t+1}|z_t}\Bigl[(1+r_{t+1}-\delta)u'(c_{t+1})\Bigr] \\
    \Rightarrow\quad u'(c_t) &= \beta\int_a^b \Bigl(1+r_{t+1}(z_{t+1})-\delta\Bigr)u'\Bigl(c_{t+1}(z_{t+1})\Bigr)f(z_{t+1}|z_t)dz_{t+1}
  \end{split}
\end{equation}

The expectation on the right-hand-side of the Euler equation is over
\(z_{t+1}\) given \(z_t\), where \(z_{t+1}\) is the AR(1) process
described at the beginning of this section. One of the most common
nonlinear solution techniques for the functional equations of the
dynamic household decision problem characterized by this Euler equation
is value function iteration on the following recursive Bellman equation.

\begin{equation}\label{NumInt_EqBellman}
  V(k,z) = \max_{k'}\:u(k,z,k') + \beta E_{z'|z}\bigl[V(k',z')\bigr]
\end{equation}

The expectation on the right-hand-side of the Bellman equation is simply
an integral of the form
\(E_{z'|z}\bigl[V(k',z')\bigr] = \int_{z'}V(k',z')f(z'|z)dz'\). However,
it is difficult to use standard Gaussian quadrature or Monte Carlo
integration methods because the value function \(V(k',z')\) is often
only known at a few points.

One solution to this problem is to interpolate or fit some continuous
function \(\tilde{V}(k',z')\) to the known points of \(V(k',z')\) and
then use Gaussian quadrature or Monte Carlo integration to approximate
the integral \(\int_{z'}\tilde{V}(k',z')f(z'|z)dz'\). Heer and Maussner
(2008) and Heer and Maussner (2009, p. 237) find that the errors in the
extrapolated values of the interpolated function \(\tilde{V}\) beyond
the bounds of the known points of \(V\) cause the solution to be less
accurate than using the Tauchen-Hussey method of approximating
\(f(z'|z)\) with a discrete first order Markov process.

    \subsection{7. References}\label{references}

\begin{itemize}
\tightlist
\item
  Adda, Jerome and Russell Cooper, \emph{Dynamic Economics: Quantitative
  Methods and Applications}, MIT Press (2003).
\item
  Armington, Paul S., "A Theory of Demand for Products Distinguished by
  Place of Production," IMF Staff Papers, 16:1, March (1969).
\item
  Dixit, Avinash K. and Joseph E. Stiglitz, "Monopolistic Competition
  and Optimum Product Diversity," \emph{American Economic Review}, 67:3,
  pp. 297-308, June (1977).
\item
  Heer, Burkhard and Alfred Maussner, "Computation of Business Cycle
  Models: A Comparison of Numerical Methods," \emph{Macroeconomic
  Dynamics}, 12:5, pp.641-663, November (2008).
\item
  Heer, Burkhard and Alfred Maussner, \emph{Dynamic General Equilibrium
  Modeling: Computational Methods and Applications}, 2nd edition,
  Springer (2009).
\item
  Judd, Kenneth L., \emph{Numerical Methods in Economics}, MIT Press,
  (1998).
\item
  Niederreiter, Harald, "Quasi-Monte Carlo Methods and Pseudo-Random
  Numbers," \emph{Bulletin of the American Mathematical Society}, 84:6,
  November (1978).
\item
  Tauchen, George, "Finite State Markov-chain Approximation to
  Univariate and Vector Autoregression," \emph{Economics Letters}, 20:2,
  pp. 177-181 (1986).
\item
  Tauchen, George and Robert Hussey, "Quadrature-based Methods for
  Obtaining Approximate Solutions to Nonlinear Asset Pricing Models,"
  \emph{Econometrica}, 59:2, pp. 371-396, March (1991).
\end{itemize}


    % Add a bibliography block to the postdoc
    
    
    
    \end{document}
